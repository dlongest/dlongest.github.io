<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Code Like A Champion</title>
		
		 <link href="/css/bootstrap.css" rel="stylesheet">
		 <link rel="icon" href="/images/logo.png" />
		 <script type="text/javascript" src="/js/jquery.js"></script>
		<script type="text/javascript" src="/js/bootstrap.js"></script>		
    <!-- Custom CSS -->
		<link href="/css/logo-nav.css" rel="stylesheet" />	
		<link href="/css/custom.css" rel="stylesheet" />
		<link rel="stylesheet" href="/css/solarized-dark.css" type="text/css"/> 

		<link href='http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic,700italic' rel='stylesheet' type='text/css' />
    </head>
    <body>
	 <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">
                    <img id="logo" src='/images/logo.png' width="125" height="125" />
                </a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/about.html">About</a>
                    </li>
					  <li>
                        <a href="#">Categories</a>
                    </li>                                       
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>	

<div class="container">
<div class="row">
 <div class="col-lg-12">		
          
	<h2><a href="/2015/03/12/basics-pipes-and-filters.html">Evolving to Pipes and Filters</a></h2>
	<div class="date">12 March 2015</div>	
	<div class="post">
	<p>In a <a href="2015/03/10/cte-and-windowing-functions.html">prior post</a>, we looked at a pretty straightforward problem:  given data set representing job applicants, we wanted to massage it into a slightly different format for import into a new system and we examined how to use common table expressions and windowing functions to achieve it with pretty minimal effort.  This same problem lends itself quite nicely to a particular design pattern called pipes and filters so in this post we will explore that technique against this same problem.  </p>

<p>A quick refresher on the problem, we have a table that resembles the below:</p>

<table class="sql">
<tr><th>Name</th><th>Phone</th><th>EyeColor</th><th>PositionID</th><th>Title</th></tr>
<tr><td>Franklin</td><td>1212</td><td>Blue</td><td>123</td><td>General Manager</td></tr>
<tr><td>Franklin</td><td>1212</td><td>Blue</td><td>67</td><td>Salesman</td></tr>
<tr><td>Pierce</td><td>1313</td><td>Blue</td><td>234</td><td>Digger</td></tr>
<tr><td>Pierce</td><td>1313</td><td>Blue</td><td>456</td><td>Porter</td></tr>
<tr><td>Hoolihan</td><td>1414</td><td>Green</td><td>123</td><td>General Manager</td></tr>
<tr><td>Bob</td><td>1515</td><td>Blue</td><td>86</td><td>Maid</td></tr>
<tr><td>Bob</td><td>1515</td><td>Blue</td><td>90</td><td>Electrician</td></tr>
</table>

<p>We want to take that representation and from it, generate a file that looks like the below.  The key pieces:  the Name, Phone, and EyeColor columns should only print one time for a given person, otherwise should be blank; the positions each person has applied for should be sequentially numbered beginning at 1. </p>

<table class="sql">
<tr><th>Name</th><th>Phone</th><th>EyeColor</th><th>PositionID</th><th>Title</th><th>PositionCount</th></tr>
<tr><td>Franklin</td><td>1212</td><td>Blue</td><td>123</td><td>General Manager</td><td>1</td></tr>
<tr><td></td><td></td><td></td><td>67</td><td>Salesman</td><td>2</td></tr>
<tr><td>Pierce</td><td>1313</td><td>Blue</td><td>234</td><td>Digger</td><td>1</td></tr>
<tr><td></td><td></td><td></td><td>456</td><td>Porter</td><td>2</td></tr>
<tr><td>Hoolihan</td><td>1414</td><td>Green</td><td>123</td><td>General Manager</td><td>1</td></tr>
<tr><td>Bob</td><td>1515</td><td>Blue</td><td>86</td><td>Maid</td><td>1</td></tr>
<tr><td></td><td></td><td></td><td>90</td><td>Electrician</td><td>2</td></tr>
</table>

<p>So how might we start this in C#? Well of course the most obvious way might be:</p>
<div class="highlight"><pre><code class="c# language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">DataProcessor</span>
<span class="p">{</span>   
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Process</span><span class="p">(</span><span class="kt">string</span> <span class="n">connectionString</span><span class="p">,</span> <span class="kt">string</span> <span class="n">outputFilename</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">/// Read records from database into some collection, say IEnumerable&lt;Applicant&gt;</span>
        <span class="c1">/// For each Applicant, either project it into a new type that contains a &quot;PositionCount&quot; property or if it&#39;s already on Applicant, enrich it</span>
        <span class="c1">/// Write each Applicant record to a file   </span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">Applicant</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Phone</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">EyeColor</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">PositionID</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">Title</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">PositionCount</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>I&#39;ve left out the code to do each piece, but it&#39;s probably exactly what you imagine.  One big thing stands out to me here:  calling this a DataProcessor is a bit of a code smell (much like calling something a <code>Manager</code>):  what are the steps involved in the processing?  What if they need to vary or are sometimes optional?  What if we want to reuse any single step in the process?  What if we want or need different input parameters to drive other processing steps?  We&#39;ve guaranteed that we will perpetually be cracking open this class and tinkering with it to address most of these questions and that&#39;s a big open-closed violation.  </p>

<p>What&#39;s one easy heuristic to spot a potential OCP violation?  Give the method a hyper specific name.  So in this case instead of calling it <code>Process</code>&#39;, what if we named it <code>ReadFromDatabaseThenAddPositionCountThenWriteToFile</code>.  That would make it much clearer that this method is doing too much.  A-ha, you might say.  What if we just broke up the single Process method into separate methods within the class, problem solved!  Or is it?</p>
<div class="highlight"><pre><code class="c# language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">DataProcessor</span>
<span class="p">{</span>   
    <span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Applicant</span><span class="p">&gt;</span> <span class="n">LoadFromDatabase</span><span class="p">(</span><span class="kt">string</span> <span class="n">connectionString</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">/// Read records from database into some collection, say IEnumerable&lt;Applicant&gt; </span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">AddPositionCount</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Applicant</span><span class="p">&gt;</span> <span class="n">applicants</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">/// Compute the number of positions applied for by each individual person and sent Applicant.PositionCount appropriately. </span>
        <span class="c1">/// Modifies the instances in the passed-in collection</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">WriteToFile</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Applicant</span><span class="p">&gt;</span> <span class="n">applicants</span><span class="p">,</span> <span class="kt">string</span> <span class="n">absoluteFilename</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">/// Write each Applicant record to a file   </span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>So now the use of our <code>DataProcessor</code> is fairly clear:</p>
<div class="highlight"><pre><code class="c# language-c#" data-lang="c#">    <span class="kt">var</span> <span class="n">processor</span> <span class="p">=</span> <span class="k">new</span> <span class="n">DataProcessor</span><span class="p">();</span>
    <span class="kt">var</span> <span class="n">applicants</span> <span class="p">=</span> <span class="n">processor</span><span class="p">.</span><span class="n">LoadFromDatabase</span><span class="p">(</span><span class="cm">/* string */</span><span class="p">);</span>
    <span class="n">processor</span><span class="p">.</span><span class="n">AddPositionCount</span><span class="p">(</span><span class="n">applicants</span><span class="p">);</span>
    <span class="n">processor</span><span class="p">.</span><span class="n">WriteToFile</span><span class="p">(</span><span class="n">applicants</span><span class="p">,</span> <span class="s">&quot;some_file.txt&quot;</span><span class="p">);</span>
</code></pre></div>
<p>Yes, much clearer, but we still have some of the same issues we had before.  If we want to add more steps, we have to open up <code>DataProcessor</code> and add methods to it.  If we wanted to reuse any of the steps (were that possible), we can&#39;t do it cleanly.  And it&#39;s pretty evident here that single responsibility principle is being violated:  this class is doing at least 3 things and that list would only grow if more were added.  So what should we do?</p>

<p>If we agree that each of the methods in the current <code>DataProcessor</code> class is its own responsibility, what if we tried to find a design that put each of those in its own class?  Just shuffling the code around, we would have:</p>
<div class="highlight"><pre><code class="c# language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">ApplicantLoader</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Applicant</span><span class="p">&gt;</span> <span class="n">LoadFromDatabase</span><span class="p">(</span><span class="kt">string</span> <span class="n">connectionString</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* */</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">ApplicantEnricher</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">AddPositionCount</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Applicant</span><span class="p">&gt;</span> <span class="n">applicants</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* */</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">ApplicantWriter</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">WriteToFile</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Applicant</span><span class="p">&gt;</span> <span class="n">applicants</span><span class="p">,</span> <span class="kt">string</span> <span class="n">absoluteFilename</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* */</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Now we&#39;ve cleaned up SRP and OCP violations quite nicely.  These classes decompose the problem into the distinct steps that previously were rather implicit (or at least coupled together) in the single <code>DataProcessor</code>.  But I think we can go one step further.  What&#39;s common about these three classes?  All of them work against a collection of Applicants.  And if we rewrite <code>ApplicantEnricher</code> as:</p>
<div class="highlight"><pre><code class="c# language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">ApplicantEnricher</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Applicant</span><span class="p">&gt;</span> <span class="n">AddPositionCount</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Applicant</span><span class="p">&gt;</span> <span class="n">applicants</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* */</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>Then we can quite clearly see there are 3 different types of activities going on here:  an initial source of Applicant records; a specific type of processing against the Applicant records that passes them forward; a sink that logically ends the processing chain in some way (such as writing to a file).  It is from this revelation that we can view this problem as befitting pipes and filters.  In this parlance a filter is a component that takes some input, processes it in some way, and sends forward either that same input or a different input.  A pipe refers to the connection between filters, but that doesn&#39;t always lend itself directly to a single component (so there may not be an <code>IPipe</code> abstraction necessarily). </p>

<p><img src="/images/pipes_and_filters.png"  /></p>

<p>One basic implementation of this pattern starts with a handful of interfaces:</p>
<div class="highlight"><pre><code class="c# language-c#" data-lang="c#"><span class="k">public</span> <span class="k">interface</span> <span class="n">ISourceInput</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">public</span> <span class="k">interface</span> <span class="n">ISource</span><span class="p">&lt;</span><span class="n">TIn</span><span class="p">,</span> <span class="n">TOut</span><span class="p">&gt;</span> <span class="k">where</span> <span class="n">TIn</span> <span class="p">:</span> <span class="n">ISourceInput</span>
<span class="p">{</span>
    <span class="n">TOut</span> <span class="nf">Load</span><span class="p">(</span><span class="n">TIn</span> <span class="n">input</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">interface</span> <span class="n">IFilter</span><span class="p">&lt;</span><span class="n">TIn</span><span class="p">,</span> <span class="n">TOut</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="n">TOut</span> <span class="nf">Filter</span><span class="p">(</span><span class="n">TIn</span> <span class="n">input</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">interface</span> <span class="n">ISink</span><span class="p">&lt;</span><span class="n">TIn</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">Sink</span><span class="p">(</span><span class="n">TIn</span> <span class="n">input</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>We define a marker interface <code>ISourceInput</code> that is used to tag any custom class we make that contains configuration or input parameters.  This isn&#39;t strictly required, but I do it to be slightly more explicit.  I find it generally true marker interfaces are a bit of a code smell.  Next the <code>ISource</code> interface is used to define our Source component.  Interestingly, since we&#39;ve stipulated the source must take an input, <code>ISource</code> and <code>IFilter</code> differ only in that the former has a type constraint but again, I think there&#39;s value in being explicit here - nothing stops you from having the filter component also implement <code>ISource</code>.   A Sink can also be a Filter if one just ignores the output from the Sink.  We can now implement our previous components in light of these interfaces:</p>
<div class="highlight"><pre><code class="c# language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">LoadApplicantSourceInput</span> <span class="p">:</span> <span class="n">ISourceInput</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">ConnectionString</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">LoadApplicantsSource</span> <span class="p">:</span> <span class="n">ISource</span><span class="p">&lt;</span><span class="n">LoadApplicantSourceInput</span><span class="p">,</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Applicant</span><span class="p">&gt;&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Applicant</span><span class="p">&gt;</span> <span class="n">Load</span><span class="p">(</span><span class="n">LoadApplicantSourceInput</span> <span class="n">input</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> 
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">ComputePositionCountForApplicantFilter</span> <span class="p">:</span> <span class="n">IFilter</span><span class="p">&lt;</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Applicant</span><span class="p">&gt;,</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Applicant</span><span class="p">&gt;&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Applicant</span><span class="p">&gt;</span> <span class="n">Filter</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Applicant</span><span class="p">&gt;</span> <span class="n">applicants</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">WriteApplicantsToFileSink</span> <span class="p">:</span> <span class="n">ISink</span><span class="p">&lt;</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Applicant</span><span class="p">&gt;&gt;</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="nf">WriteApplicantsToFileSink</span><span class="p">(</span><span class="kt">string</span> <span class="n">filename</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Sink</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Applicant</span><span class="p">&gt;</span> <span class="n">applicants</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>It&#39;s roughly the same code as we wrote initially, but we&#39;ve simply split it up into components and raised the level of abstraction.  There&#39;s arguably a few strange things (why does the Source take an input for the connection string, but we provide the output file name to the Sink as a constructor argument) but any of those could be cleaned up or changed based on preference or the particular system they&#39;re being employed in.</p>
 	
	</div>
	<hr />
      
	<h2><a href="/2015/03/10/cte-and-windowing-functions.html">Basics of Common Table Expressions and Windowing Functions</a></h2>
	<div class="date">10 March 2015</div>	
	<div class="post">
	<p>Most developers are aware of how to use basic SQL constructs (Select, Update, Insert) even if their level of database programming is very minimal.  I was fortunate that before I was a fulltime developer, I worked in a role that required me to read, write, and troubleshoot an intense amount of SQL (and actually wasn&#39;t a DBA job).  Over the course of time, I became pretty fair at SQL and others used to bring me random SQL problems for help.  Most of these were straightforward enough problems, but occasionally I would get one that was really difficult, and I really enjoyed those.  Last night a current colleague of mine emailed me about a problem he was having doing some integration work and the solution was a set of SQL Server features that I think deserve to be talked about more:  common table expressions (CTE) and windowing functions.  There&#39;s a lot of power there and it can be overwhelming so the point of this post is to simply describe the problem and then illustrate how CTE and windowing functions made the solution pretty trivial.  </p>

<p>Here&#39;s the problem:  we have a table of data about employment applicants (i.e. people who have applied for jobs) in a legacy system.  We&#39;re moving to a new system so we need to take the data from the first system and transform it into a format required by the second system so it can be imported.  </p>

<p>First, here&#39;s the data in the legacy system in a single table (greatly stripped down for illustrative purposes, the real one has about 250+ columns):</p>

<table class="sql">
<tr><th>Name</th><th>Phone</th><th>EyeColor</th><th>PositionID</th><th>Title</th></tr>
<tr><td>Franklin</td><td>1212</td><td>Blue</td><td>123</td><td>General Manager</td></tr>
<tr><td>Franklin</td><td>1212</td><td>Blue</td><td>67</td><td>Salesman</td></tr>
<tr><td>Pierce</td><td>1313</td><td>Blue</td><td>234</td><td>Digger</td></tr>
<tr><td>Pierce</td><td>1313</td><td>Blue</td><td>456</td><td>Porter</td></tr>
<tr><td>Hoolihan</td><td>1414</td><td>Green</td><td>123</td><td>General Manager</td></tr>
<tr><td>Bob</td><td>1515</td><td>Blue</td><td>86</td><td>Maid</td></tr>
<tr><td>Bob</td><td>1515</td><td>Blue</td><td>90</td><td>Electrician</td></tr>
</table>

<p>We&#39;ll call Name, Phone, and EyeColor the &quot;key&quot; fields.  That&#39;s a bit of a misnomer since these keys don&#39;t uniquely identify a single record, but I&#39;m using the term simply to mean that those values are the same for a single person.  We need to sequentially number each record with the same key (and we&#39;ll call it PositionCount).  Franklin has two records so the first is 1 and the second is 2, but Hoolihan has only a single record so its sole record is 1.  We only want to print the key fields for the first position record; otherwise we want to print blanks for the key fields, but still print the position data.  Here&#39;s how we want the data to look for loading into the target system.  </p>

<table class="sql">
<tr><th>Name</th><th>Phone</th><th>EyeColor</th><th>PositionID</th><th>Title</th><th>PositionCount</th></tr>
<tr><td>Franklin</td><td>1212</td><td>Blue</td><td>123</td><td>General Manager</td><td>1</td></tr>
<tr><td></td><td></td><td></td><td>67</td><td>Salesman</td><td>2</td></tr>
<tr><td>Pierce</td><td>1313</td><td>Blue</td><td>234</td><td>Digger</td><td>1</td></tr>
<tr><td></td><td></td><td></td><td>456</td><td>Porter</td><td>2</td></tr>
<tr><td>Hoolihan</td><td>1414</td><td>Green</td><td>123</td><td>General Manager</td><td>1</td></tr>
<tr><td>Bob</td><td>1515</td><td>Blue</td><td>86</td><td>Maid</td><td>1</td></tr>
<tr><td></td><td></td><td></td><td>90</td><td>Electrician</td><td>2</td></tr>
</table>

<p>The first part to tackle:  how can we determine the position counts?  Most people can instantly think of an imperative solution (just loop through the records, adding an incrementing value to that column, resetting for each person), but in SQL we want to think relationally.  A <code>Group By</code> would let us group the records by our keys, but at best we could obtain a count of the records in the group, not quite what we want.  It&#39;s here that a windowing function really shines.  </p>

<p>At the most basic level, a windowing function lets us define a partition (which is similar to a group) against which we can execute some statement.  Below is the SQL that will do the job for me:</p>
<div class="highlight"><pre><code class="sql language-sql" data-lang="sql"><span class="k">select</span> <span class="o">*</span><span class="p">,</span> <span class="n">row_number</span><span class="p">()</span> <span class="n">over</span> <span class="p">(</span><span class="n">partition</span> <span class="k">by</span> <span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="k">order</span> <span class="k">by</span> <span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="k">asc</span><span class="p">)</span> <span class="k">as</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span> <span class="k">from</span> <span class="n">Persons</span><span class="p">)</span>
</code></pre></div>
<p>Probably not terribly hard to understand, but the <code>OVER</code> function is the windowing function.  We instruct it to partition our set based on <code>Name</code>, then order it by <code>Name</code> (which is required), then apply SQL Server&#39;s row_number() function within each partition.  This will have the effect we want: the first record in each partition will get the value 1, the next 2, and so on, but the counts reset for each partition.  By modifying the partition columns, you can control to what level the records are numbered.  See the documentation on the  <a href="https://msdn.microsoft.com/en-us/library/ms189461.aspx">OVER function on MSDN</a> to learn more.   The shown SQL is now capable of providing this result set:</p>

<table class="sql">
<tr><th>Name</th><th>Phone</th><th>EyeColor</th><th>PositionID</th><th>Title</th><th>PositionCount</th></tr>
<tr><td>Franklin</td><td>1212</td><td>Blue</td><td>123</td><td>General Manager</td><td>1</td></tr>
<tr><td>Franklin</td><td>1212</td><td>Blue</td><td>67</td><td>Salesman</td><td>2</td></tr>
<tr><td>Pierce</td><td>1313</td><td>Blue</td><td>234</td><td>Digger</td><td>1</td></tr>
<tr><td>Pierce</td><td>1313</td><td>Blue</td><td>456</td><td>Porter</td><td>2</td></tr>
<tr><td>Hoolihan</td><td>1414</td><td>Green</td><td>123</td><td>General Manager</td><td>1</td></tr>
<tr><td>Bob</td><td>1515</td><td>Blue</td><td>86</td><td>Maid</td><td>1</td></tr>
<tr><td>Bob</td><td>1515</td><td>Blue</td><td>90</td><td>Electrician</td><td>2</td></tr>
</table>

<p>From here, what we want to achieve is conceptually pretty easy:  we only want to print the value of the key fields when <code>PositionCount</code> is 1, otherwise we want to print a blank (or null).  We could of course make a new table (either temporary or real) and put our newly formed result set in that, then operate against it, but a common table expression (a CTE) is for me faster to develop (albeit with some caveats I&#39;ll cover at the end). </p>

<p>What is a common table expression (CTE)?  Without cribbing directly from Microsoft on the subject, it&#39;s in many ways an in-memory view.  You provide it with a name and you can thereafter use that name for the result set, same as you would a query.  The CTE can be used recursively in other queries and combined in some very powerful ways.  They are incredibly useful if you&#39;ll be referencing the same table or result set multiple times within a query as you can apply a name to that set and just use the name.  And due to how they&#39;re defined, they make queries a lot easier to read as they basically build from the top down in an organized fashion, which is genearlly far easier to decipher than a query with a lot of nested queries. </p>

<p>A CTE is defined in either of the forms:</p>
<div class="highlight"><pre><code class="sql language-sql" data-lang="sql"><span class="k">WITH</span> <span class="p">(</span><span class="n">CTE</span> <span class="n">Name</span><span class="o">&gt;</span> <span class="k">AS</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">query</span> <span class="n">definition</span><span class="o">&gt;</span><span class="p">)</span> 

<span class="k">WITH</span> <span class="o">&lt;</span><span class="n">CTE</span> <span class="n">Name</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">&lt;</span><span class="k">column</span> <span class="k">names</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">AS</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">query</span> <span class="n">definition</span><span class="o">&gt;</span><span class="p">)</span>
</code></pre></div>
<p>The first form defines a CTE with the given name and its columns will be all the columns from the query definition.  The second allows you to specify the column names you want available in the CTE; these are drawn from the query definition.  Only those columns defined in the CTE are then avaiable.  So what&#39;s the point of the CTE?  You can then use it like a table: </p>
<div class="highlight"><pre><code class="sql language-sql" data-lang="sql"><span class="k">with</span> <span class="n">PositionsCounted</span> <span class="k">as</span> <span class="p">(</span><span class="k">select</span> <span class="o">*</span><span class="p">,</span> <span class="n">row_number</span><span class="p">()</span> <span class="n">over</span> <span class="p">(</span><span class="n">partition</span> <span class="k">by</span> <span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="k">order</span> <span class="k">by</span> <span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="k">asc</span><span class="p">)</span> <span class="k">as</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span> <span class="k">from</span> <span class="n">Persons</span><span class="p">)</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">PositionsCounted</span>
</code></pre></div>
<p>The above SQL is equivalent to just executing the query definition directly, all we&#39;ve really done at this point is given the result set a name we can operate against.  But for the final piece, we can do this to produce our final result set:</p>
<div class="highlight"><pre><code class="sql language-sql" data-lang="sql"><span class="k">with</span> <span class="n">PositionsCounted</span> <span class="k">as</span> <span class="p">(</span><span class="k">select</span> <span class="o">*</span><span class="p">,</span> <span class="n">row_number</span><span class="p">()</span> <span class="n">over</span> <span class="p">(</span><span class="n">partition</span> <span class="k">by</span> <span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="k">order</span> <span class="k">by</span> <span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="k">asc</span><span class="p">)</span> <span class="k">as</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span> <span class="k">from</span> <span class="n">Persons</span><span class="p">)</span>
<span class="k">select</span> <span class="k">case</span> <span class="k">when</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">then</span> <span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="k">end</span><span class="p">,</span>
       <span class="k">case</span> <span class="k">when</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">then</span> <span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="p">[</span><span class="n">Phone</span><span class="p">]</span> <span class="k">end</span><span class="p">,</span>
       <span class="k">case</span> <span class="k">when</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">then</span> <span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="p">[</span><span class="n">EyeColor</span><span class="p">]</span> <span class="k">end</span><span class="p">,</span>
       <span class="p">[</span><span class="n">PositionID</span><span class="p">],</span> <span class="p">[</span><span class="n">Title</span><span class="p">],</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span> 
       <span class="k">from</span> <span class="n">PositionsCounted</span>
</code></pre></div>
<p>The trick to this SQL is that for each of our key fields, we inspect the value of <code>PositionCount</code> and that determines what we should output (either the value of the column or a blank).  Otherwise, we simply want the non-key fields returned as-is.  Obviously this approach is difficult to scale if there are hundreds of key fields (as each would have to be added manually as a case expression), but in this case when there&#39;s only a minimal number of key fields, it&#39;s trivial. </p>

<p>CTEs can be combined as well, such as the below, which simply puts the output of the first CTE into the second, a trivial but hopefully illustrative example:</p>
<div class="highlight"><pre><code class="sql language-sql" data-lang="sql"><span class="k">with</span> <span class="n">PositionsCounted</span> <span class="k">as</span> <span class="p">(</span><span class="k">select</span> <span class="o">*</span><span class="p">,</span> <span class="n">row_number</span><span class="p">()</span> <span class="n">over</span> <span class="p">(</span><span class="n">partition</span> <span class="k">by</span> <span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="k">order</span> <span class="k">by</span> <span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="k">asc</span><span class="p">)</span> <span class="k">as</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span> <span class="k">from</span> <span class="n">Persons</span><span class="p">),</span>
<span class="n">OutputReady</span> <span class="k">as</span> 
<span class="p">(</span><span class="k">select</span> <span class="k">case</span> <span class="k">when</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">then</span> <span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="k">end</span> <span class="p">[</span><span class="n">Name</span><span class="p">],</span>
       <span class="k">case</span> <span class="k">when</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">then</span> <span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="p">[</span><span class="n">Phone</span><span class="p">]</span> <span class="k">end</span> <span class="p">[</span><span class="n">Phone</span><span class="p">],</span>
       <span class="k">case</span> <span class="k">when</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">then</span> <span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="p">[</span><span class="n">EyeColor</span><span class="p">]</span> <span class="k">end</span> <span class="p">[</span><span class="n">EyeColor</span><span class="p">],</span>
       <span class="p">[</span><span class="n">PositionID</span><span class="p">],</span> <span class="p">[</span><span class="n">Title</span><span class="p">],</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span> 
       <span class="k">from</span> <span class="n">PositionsCounted</span><span class="p">)</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">OutputReady</span>
</code></pre></div>
<p>So we&#39;ve seen some benefits of CTE, what are the downsides?  First, they are only in scope for a single query.  If you want to reuse them, they have to be copied and pasted into all places that need to reference them.  If you have such a need, temp tables or something more permanent (or semi-permanent) is a better bet.  Second, because they do not exist in tempdb, you cannot add indexes or anything that would improve the performance (and constraints and stats are likewise not available).  Again, if that&#39;s your need, a temp table would be more in order.  </p>

<p>I hope you&#39;ve enjoyed this basic look at common table expressions and windowing functions in SQL Server.  This has only scratched the surface of these features so I definitely suggest working through some examples to get a feel for how and when each can be applied in real life situations.  </p>
 	
	</div>
	<hr />
  



 
	</div>
</div>
</div>
<ul class="pager">
 	
	  
	 <li>
    <a  href="/page2/" title="Older">Older &raquo;</a>
	</li>
     
</ul>		
   


  
	
</body>
</html>