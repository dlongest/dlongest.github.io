<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <!--<title>Home</title>-->
		<link rel="stylesheet" href="/css/normalize.min.css" type="text/css" />
		<link rel="stylesheet" href="/css/solarized-dark.css" type="text/css"/>
		<link rel="stylesheet" href="/css/main.css" type="text/css" />
		<link rel="stylesheet" href="/css/header.css" type="text/css"/>
		<link href='http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic,700italic' rel='stylesheet' type='text/css' />
    </head>
    <body>
	<div id="header">
	<a href="http://dlongest.github.io/" title="Dan Longest's Blog Homepage"><img id="logo" src='/images/logo.png' /></a>
	<nav>
	  <ul>
	    <li><a href="posts.html">Posts</a></li>
	    <li><a href="#">Categories</a></li>	    
		<li><a href="#">Recommended</a></li>	    
	    <li><a href="#">About</a></li>
	  </ul>
    </nav>
	</div>

    <div class="maincontent">
      
	<h2>Extending the MVC Default Model Binder</h2>
	<em>20 January 2015</em>
	<p>In the <a href="2014-12-14-writing-a-custom-mvc-model-validator">last post</a>, I talked about authoring custom MVC model validators that can be plugged into MVC&#39;s model validation pipeline.  In this post, I will go into some details on how we used a custom model binder to execute some logic after default model validation, but prior to MVC&#39;s model validation being executed.  </p>

<p>In the login application we were writing, there were two cases when we wanted to update the model prior to validation (so that validation would apply), but I didn&#39;t want to write a separate per-type model binder.  In MVC, you can define the application-wide model binder in the application root by doing:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="n">ModelBinders</span><span class="p">.</span><span class="n">Binders</span><span class="p">.</span><span class="n">DefaultBinder</span> <span class="p">=</span> <span class="k">new</span> <span class="n">MyCustomModelBinder</span><span class="p">();</span>
</code></pre></div>
<p>This binder will completely replace the default binder although generally it&#39;s easiest to inherit from the <code>DefaultModelBinder</code> and just extend the necessary method.  But figuring out exactly what to extend and what to reuse isn&#39;t necessarily obvious.  </p>

<p>In our case, there were a few things we needed to do:
- We needed to pass values between web requests, but in some cases the values were sensitive so we encrypted them as hidden fields, but needed to decrypt them automatically during model binding
- The vendor stack that actually provides the backing store will provide some user-specific data in the HTTP header on certain views and we wanted to automatically bind those</p>

<p>In both cases, it would be possible to extend one of the MVC components to do these jobs, but a couple things bothered me:
- Each time we came up with additional model binding that needed to occur, we would have to implement a new model binder and figure out how to incorporate previously logic or violate Open-Closed and keep making changes to our binder.
- We could write a HTTP Header Value Provider, but it was only needed a fraction of times for a couple specific fields and the property on the view model we would populate had a different name so would have to figure out some alias system
- It is possible to write per-type model binders and that might have worked for the cases where we were populating header values into the view model (since there were really 3 use-case specific ones of these), but our decryption can theoretically apply to fields on any view model and I didn&#39;t want to have to define a per-type binder when the goal of encryption was to simply annotate properties and have it work. </p>

<p>So it occurred to us that what we wanted to have happen was:
- Use the <code>DefaultModelBinder</code> up to the point when it runs model validation
- At this point, run components against the completely bound model that would update the model as they saw fit (again, similar to model binding, hence the timing)
- Once all those components completed, have the <code>DefaultModelBinder</code> run its custom validation logic as it normally would. </p>

<p>This brings me to the first key in the process:  what method in the <code>DefaultModelBinder</code> needs to be overridden to give us access to a completely bound but not yet validated view model?  The answer:  OnModelUpdated.  The below snippet shows the implementation of the OnModelUpdated method on DefaultModelBinder pulled from the MVC source code on CodePlex.  This is the only method that uses the model validators by way of using the application-wide static ModelValidator instance to get the validators to iterate through.  </p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="k">protected</span> <span class="k">virtual</span> <span class="k">void</span> <span class="nf">OnModelUpdated</span><span class="p">(</span><span class="n">ControllerContext</span> <span class="n">controllerContext</span><span class="p">,</span> <span class="n">ModelBindingContext</span> <span class="n">bindingContext</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">startedValid</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;(</span><span class="n">StringComparer</span><span class="p">.</span><span class="n">OrdinalIgnoreCase</span><span class="p">);</span>

            <span class="k">foreach</span> <span class="p">(</span><span class="n">ModelValidationResult</span> <span class="n">validationResult</span> <span class="k">in</span> <span class="n">ModelValidator</span><span class="p">.</span><span class="n">GetModelValidator</span><span class="p">(</span><span class="n">bindingContext</span><span class="p">.</span><span class="n">ModelMetadata</span><span class="p">,</span> <span class="n">controllerContext</span><span class="p">).</span><span class="n">Validate</span><span class="p">(</span><span class="k">null</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="kt">string</span> <span class="n">subPropertyName</span> <span class="p">=</span> <span class="n">CreateSubPropertyName</span><span class="p">(</span><span class="n">bindingContext</span><span class="p">.</span><span class="n">ModelName</span><span class="p">,</span> <span class="n">validationResult</span><span class="p">.</span><span class="n">MemberName</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(!</span><span class="n">startedValid</span><span class="p">.</span><span class="n">ContainsKey</span><span class="p">(</span><span class="n">subPropertyName</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="n">startedValid</span><span class="p">[</span><span class="n">subPropertyName</span><span class="p">]</span> <span class="p">=</span> <span class="n">bindingContext</span><span class="p">.</span><span class="n">ModelState</span><span class="p">.</span><span class="n">IsValidField</span><span class="p">(</span><span class="n">subPropertyName</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">startedValid</span><span class="p">[</span><span class="n">subPropertyName</span><span class="p">])</span>
                <span class="p">{</span>
                    <span class="n">bindingContext</span><span class="p">.</span><span class="n">ModelState</span><span class="p">.</span><span class="n">AddModelError</span><span class="p">(</span><span class="n">subPropertyName</span><span class="p">,</span> <span class="n">validationResult</span><span class="p">.</span><span class="n">Message</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div>
<p>So at this point, we know one thing we need to do: implement our own model binder that inherits from <code>DefaultModelBinder</code>, overrides OnModelUpdated to hook in our custom logic, and ultimately call base.OnModelUpdated to run the default validation.  But before we implement that, we need to think about what our new update components will look like. </p>

<p>Conceptually, we&#39;re going to pass the model from the model binder (and the model can be of any type) to a component and that component is going to potentially modify properties on it directly based on its rules.  So let&#39;s define an interface <code>IModelUpdate</code> which does that, with the addition of ControllerContext:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">    <span class="k">public</span> <span class="k">interface</span> <span class="n">IModelUpdate</span>
    <span class="p">{</span>
        <span class="k">void</span> <span class="nf">Update</span><span class="p">(</span><span class="kt">object</span> <span class="n">model</span><span class="p">,</span> <span class="n">ControllerContext</span> <span class="n">controllerContext</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>
<p>As mentioned, the model updates we&#39;d like to apply are:
- Decrypt specific properties based on annotations
- Bind values from the HTTP request</p>

<p>These become several implementations of <code>IModelUpdate</code> that are then plugged into our custom model binder, which looks like:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">PreValidationModelUpdatingModelBinder</span> <span class="p">:</span> <span class="n">DefaultModelBinder</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">IModelUpdate</span><span class="p">&gt;</span> <span class="n">modelUpdates</span><span class="p">;</span>

        <span class="k">public</span> <span class="nf">PreValidationModelUpdatingModelBinder</span><span class="p">(</span><span class="k">params</span> <span class="n">IModelUpdate</span><span class="p">[]</span> <span class="n">modelUpdates</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">modelUpdates</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
                <span class="k">this</span><span class="p">.</span><span class="n">modelUpdates</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">IModelUpdate</span><span class="p">&gt;();</span>
            <span class="k">else</span>
                <span class="k">this</span><span class="p">.</span><span class="n">modelUpdates</span> <span class="p">=</span> <span class="n">modelUpdates</span><span class="p">.</span><span class="n">ToList</span><span class="p">();</span>
        <span class="p">}</span>      

        <span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OnModelUpdated</span><span class="p">(</span><span class="n">ControllerContext</span> <span class="n">controllerContext</span><span class="p">,</span> <span class="n">ModelBindingContext</span> <span class="n">bindingContext</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">modelUpdates</span><span class="p">.</span><span class="n">ToList</span><span class="p">().</span><span class="n">ForEach</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">Update</span><span class="p">(</span><span class="n">bindingContext</span><span class="p">.</span><span class="n">Model</span><span class="p">,</span> <span class="n">controllerContext</span><span class="p">));</span>           

            <span class="k">base</span><span class="p">.</span><span class="n">OnModelUpdated</span><span class="p">(</span><span class="n">controllerContext</span><span class="p">,</span> <span class="n">bindingContext</span><span class="p">);</span>            
        <span class="p">}</span>       
    <span class="p">}</span>    
</code></pre></div>
<p>As you can see, our model binder simply takes a collection of IModelUpdate components, overrides OnModelUpdated, calls each component, and then calls base.OnModelUpdated to have the default model binder run the model validations.  Each model updater is responsible for determining
if it actually cares to perform an update on the model; if not, it simply does nothing to it.  I&#39;ve omitted the implementations of the <code>IModelUpdate</code> components as they&#39;re pretty application specific, but they are in my <a href="https://gist.github.com/dlongest/387d2ce35fb6f45688b8">Github</a> if you&#39;d like to see them.  </p>

<p>This concludes a look at how we extended MVC to leverage its existing binding and validation functionality while letting us extend it in some pretty unique ways. </p>
 
	</p>
      
	<h2>Writing a Custom MVC Model Validator</h2>
	<em>14 December 2014</em>
	<p>The power of ASP.NET MVC is how extensible the framework is, but with this comes a challenge:  in certain cases as a developer you know (or have a feeling) that there is an extension point, but how do you find and use the right one?  In a series of posts, I will explore the myriad extension points in MVC from the perspective of a project I&#39;ve been working on for a few months.  Like most development, every situation has an almost limitless number of options for accomplishing it, but with regards to extending MVC in my experience there is often one &quot;best&quot; choice, the key is being aware of it.  </p>

<p>To establish some context, here&#39;s the project: a login application.  There are thousands (or millions) of these available so why would we be writing our own?  I work for a not-for-profit company and we made the decision to license a popular identity access management (IAM) platform from a vendor and partner with a second company to implement and support it for us.  Initially, there had been no development work planned on our side at all: the implementer would take care of all of it with an out-of-the-box login application configured against various cloud services (provided by the solution vendor, but running in the implementer&#39;s cloud).  However, the OOTB application was not responsive, which was a big deal for us so the decision was made for us to write our own.  Conceptually, this seemed straightforward enough: the login application would (in theory) simply make calls to either a REST service (for logging in) or a SOAP service (for most other identity functions, password resets and the like).  However, over time our custom login application began to accrue more and more functionality as the implementer struggled to support our requirements within the vendor solution.  It is this difficulty supporting some requirements that led us to extending the framework in various ways. </p>

<p>There are plenty of other posts and articles out on the web that describe the order of certain actions in the framework and I won&#39;t go into those in detail, but the key is this order:</p>

<ul>
<li>Model binding (which includes model validation)</li>
<li>Filters (authorization, action, result)</li>
</ul>

<p>Model binding is the set of components that populate a model (which is often a view model, but can be any type which is the parameter for a controller action), using values pulled from the value provider.  A value provider is an abstraction over the HTTP request itself plus whatever custom value providers have been defined.  Under the hood there are several different default providers (one for querystring values, one for posted data, etc), but they are gathered together into a composite pattern (so if you look at the ControllerContext.Controller.ValueProvider, it is a single instance).  As the binding progresses, the model binder fetches model validators out of the framework&#39;s static <code>ModelValidatorProviders</code> collection and executes each validator.  An individual model validator looks at some part of the model that it cares about and generates a <code>ModelValidationResult</code> containing error text if the validation fails that the model binder then writes into the model state error. </p>

<p>So here&#39;s the situation: like most enterprises, we have specific rules governing a user&#39;s password, but the vendor IAM platform simply could not be configured to support our custom rules in concert with disabling certain out of the box rules we didn&#39;t want to use (yes, very bizarre, I agree).  What are our custom rules? </p>

<ul>
<li>Can&#39;t use certain banned phrases in the password</li>
<li>Can&#39;t use your first name or last name anywhere in the password</li>
<li>Password must be between 8 and 30 characters long</li>
<li>Password must have a lowercase character, an uppercase character, and a number</li>
<li>Password cannot have certain special characters (or said another way, we only support a limited numuber of non-alphanumeric characters)</li>
</ul>

<p>A few of the rules are supported trivially with model annotations, such as the length (using <code>StringLength</code>) and acceptable alphanumeric characters (using custom RegEx attributes if nothing else).  However, the restrictions on first name and last name and banned phrases are much more difficult, especially: where do the first name and last name come from?  Where do the banned phrases come from?  An attribute could be written to do this, but it would almost definitely not be unit testable. </p>

<p>It feels in this case like model validation is still the right mechanism to use: it&#39;s built into the framework and will run for us automatically so let&#39;s start by writing a model validator to validate the password.  </p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"> <span class="k">public</span> <span class="k">class</span> <span class="nc">PasswordValidator</span> <span class="p">:</span> <span class="n">ModelValidator</span>
    <span class="p">{</span>

        <span class="k">public</span> <span class="nf">PasswordValidator</span><span class="p">(</span><span class="n">IAllowPassword</span> <span class="n">allowPassword</span><span class="p">,</span> <span class="n">ModelMetadata</span> <span class="n">metadata</span><span class="p">,</span>
                                 <span class="n">ControllerContext</span> <span class="n">context</span><span class="p">)</span>
            <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">PasswordProperty</span> <span class="p">=</span> <span class="n">metadata</span><span class="p">.</span><span class="n">ModelType</span><span class="p">.</span><span class="n">GetProperties</span><span class="p">().</span><span class="n">First</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">Attribute</span><span class="p">.</span><span class="n">IsDefined</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">PasswordFormatAttribute</span><span class="p">)));</span>
            <span class="k">this</span><span class="p">.</span><span class="n">Password</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">PasswordProperty</span><span class="p">.</span><span class="n">GetValue</span><span class="p">(</span><span class="n">metadata</span><span class="p">.</span><span class="n">Model</span><span class="p">,</span> <span class="k">null</span><span class="p">)</span> <span class="k">as</span> <span class="kt">string</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="n">AllowPasswordPolicy</span> <span class="p">=</span> <span class="n">allowPassword</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">PropertyInfo</span> <span class="n">PasswordProperty</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="kt">string</span> <span class="n">Password</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="n">IAllowPassword</span> <span class="n">AllowPasswordPolicy</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>


        <span class="k">public</span> <span class="k">override</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">ModelValidationResult</span><span class="p">&gt;</span> <span class="n">Validate</span><span class="p">(</span><span class="kt">object</span> <span class="n">container</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">try</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">notAllowedReasons</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">AllowPasswordPolicy</span><span class="p">.</span><span class="n">IsAllowed</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Password</span><span class="p">);</span>

                <span class="k">return</span> <span class="n">notAllowedReasons</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">CreateResult</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>

            <span class="p">}</span>
            <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">Enumerable</span><span class="p">.</span><span class="n">Empty</span><span class="p">&lt;</span><span class="n">ModelValidationResult</span><span class="p">&gt;();</span>
            <span class="p">}</span>
        <span class="p">}</span>    


        <span class="k">protected</span> <span class="n">ModelValidationResult</span> <span class="nf">CreateResult</span><span class="p">(</span><span class="kt">string</span> <span class="n">message</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">ModelValidationResult</span>
            <span class="p">{</span>
                <span class="n">MemberName</span> <span class="p">=</span> <span class="s">&quot;Password&quot;</span><span class="p">,</span>
                <span class="n">Message</span> <span class="p">=</span> <span class="n">message</span>
            <span class="p">};</span>
        <span class="p">}</span>
    <span class="p">}</span>   
</code></pre></div>
<p>The <code>PasswordValidator</code> relies on a collection of <code>IAllowPassword</code> rules to decide if a given password is acceptable or not.  The validator is created by a custom instance of <code>ModelValidatorProvider</code> which in this case looks up the banned phrsaes from the web.config and then instantiates the other IAllowPassword instances:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">WebConfigPasswordComplexityModelValidatorProvider</span> <span class="p">:</span> <span class="n">ModelValidatorProvider</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">bannedPhrases</span><span class="p">;</span>        

        <span class="k">public</span> <span class="nf">WebConfigPasswordComplexityModelValidatorProvider</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">config</span> <span class="p">=</span> <span class="n">ConfigurationManager</span><span class="p">.</span><span class="n">GetSection</span><span class="p">(</span><span class="s">&quot;passwordComplexityRules&quot;</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="p">==</span><span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="n">bannedPhrases</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">passwordConfig</span> <span class="p">=</span> <span class="p">(</span><span class="n">PasswordComplexityRulesConfigurationSection</span><span class="p">)</span><span class="n">config</span><span class="p">;</span>

                <span class="k">this</span><span class="p">.</span><span class="n">bannedPhrases</span> <span class="p">=</span> <span class="n">passwordConfig</span><span class="p">.</span><span class="n">BannedPhrases</span>
                                       <span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">PasswordComplexityBannedPhraseConfigurationElement</span><span class="p">&gt;()</span>
                                       <span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">Phrase</span><span class="p">);</span>
            <span class="p">}</span>           
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">override</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">ModelValidator</span><span class="p">&gt;</span> <span class="n">GetValidators</span><span class="p">(</span><span class="n">ModelMetadata</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">ControllerContext</span> <span class="n">context</span><span class="p">)</span>
        <span class="p">{</span>              
            <span class="k">if</span> <span class="p">(!</span><span class="k">typeof</span><span class="p">(</span><span class="n">AutomaticReturnViewModel</span><span class="p">).</span><span class="n">IsAssignableFrom</span><span class="p">(</span><span class="n">metadata</span><span class="p">.</span><span class="n">ModelType</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">Enumerable</span><span class="p">.</span><span class="n">Empty</span><span class="p">&lt;</span><span class="n">ModelValidator</span><span class="p">&gt;();</span>

            <span class="k">if</span> <span class="p">(!</span><span class="n">metadata</span><span class="p">.</span><span class="n">ModelType</span><span class="p">.</span><span class="n">GetProperties</span><span class="p">().</span><span class="n">Any</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">Attribute</span><span class="p">.</span><span class="n">IsDefined</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">PasswordFormatAttribute</span><span class="p">))))</span>
                <span class="k">return</span> <span class="n">Enumerable</span><span class="p">.</span><span class="n">Empty</span><span class="p">&lt;</span><span class="n">ModelValidator</span><span class="p">&gt;();</span>

            <span class="k">return</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ModelValidator</span><span class="p">&gt;</span>
            <span class="p">{</span>
                <span class="k">new</span> <span class="nf">PasswordValidator</span><span class="p">(</span><span class="k">new</span> <span class="n">CompositeAllowPassword</span><span class="p">(</span>
                                        <span class="k">new</span> <span class="nf">CannotUseInPasswordAttributeValuesNotAllowed</span><span class="p">(</span><span class="n">metadata</span><span class="p">.</span><span class="n">Model</span><span class="p">),</span>
                                        <span class="k">new</span> <span class="nf">PasswordWithBannedPhrasesNotAllowed</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">bannedPhrases</span><span class="p">)),</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
            <span class="p">};</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<p>Our custom ModelValidatorProvider is hooked into the framework in the Global.asax:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"> <span class="n">ModelValidatorProviders</span><span class="p">.</span><span class="n">Providers</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">WebConfigPasswordComplexityModelValidatorProvider</span><span class="p">());</span>
</code></pre></div>
<p>Now for the actual <code>IAllowPassword</code> implementations.</p>

<p>First, <code>PasswordWithBannedPhrasesNotAllowed</code> takes a collection of banned phrases (simple strings) and just verifies if the possiblePassword contains any of them.  </p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">PasswordWithBannedPhrasesNotAllowed</span> <span class="p">:</span> <span class="n">IAllowPassword</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">PasswordWithBannedPhrasesNotAllowed</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">bannedPhrases</span><span class="p">)</span>
            <span class="p">:</span> <span class="k">this</span><span class="p">(</span><span class="n">bannedPhrases</span><span class="p">,</span> <span class="n">ControllerResources</span><span class="p">.</span><span class="n">Password_Phrase_NotAllowed</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="nf">PasswordWithBannedPhrasesNotAllowed</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">bannedPhrases</span><span class="p">,</span> <span class="kt">string</span> <span class="n">errorMessage</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">BannedPhrases</span> <span class="p">=</span> <span class="n">bannedPhrases</span> <span class="p">??</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>
            <span class="k">this</span><span class="p">.</span><span class="n">ErrorMessage</span> <span class="p">=</span> <span class="n">errorMessage</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">BannedPhrases</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">IsAllowed</span><span class="p">(</span><span class="kt">string</span> <span class="n">possiblePassword</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">BannedPhrases</span><span class="p">.</span><span class="n">Any</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">possiblePassword</span><span class="p">.</span><span class="n">ContainsIgnoreCase</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
                <span class="k">return</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="n">ErrorMessage</span> <span class="p">};</span>

            <span class="k">return</span> <span class="n">Enumerable</span><span class="p">.</span><span class="n">Empty</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">string</span> <span class="n">ErrorMessage</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<p>Next is the more interesting rule that a password cannot contain a first name or last name.  The challenging part of this instance is: how does it know where to find the first name and last name?  Does it have to look it up or is the field available to it somewhere (such as on the model)?  Can it work in a consistent way across any view model that has a password (which, for us, is ChangePasswordViewModel, ResetPasswordViewModel, and CreateAccountViewModel, as all of them allow a user to input a new password)?  </p>

<p>Here&#39;s one approach.  First, let&#39;s say that the view model needs to have the first name and last name that should be used for validation.  In some cases, the user is entering the first name and last name when they enter a new password so it&#39;s a natural fit (e.g. creating an account).  In other cases, first name and last name aren&#39;t entered by the user so we must figure out some way to populate them.  That may seem like a hardship (and a later post will outline a way we did that), but think about the component we&#39;re writing currently:  a model validator.  The validator does not (and should not) care how a view model is bound: its only precondition is the view model has been completely bound and is ready to be validated.  So we will temporarily shelve the concerns about how we&#39;ll put first name and last name into the model and just assume they can be put in there for us by some model binder.  </p>

<p>That leaves only one final issue:  how should our rule know that a given field is a first name or last name field?  One way is to provide it with property names (or property names mapped to a view model type) and that would work fine.  It would be implicit though while most model binding and validation is driven explicitly via annotations (of course, the banned phrase validator above is implicit).  Let&#39;s define a <code>CannotUseInPasswordAttribute</code> (with no behavior) that can be placed on any property on the view model that indicates it cannot be part of the password, then have our rule simply find those properties with that annotation and voila, it knows what fields are ineligible.  Each particular annotation will include the error message that should be written into the model state error (so the message for first name and last name could be different).  </p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"> <span class="k">public</span> <span class="k">class</span> <span class="nc">CannotUseInPasswordAttribute</span> <span class="p">:</span> <span class="n">Attribute</span> 
    <span class="p">{</span>
        <span class="k">private</span> <span class="kt">string</span> <span class="n">errorMessage</span><span class="p">;</span>

        <span class="k">public</span> <span class="kt">string</span> <span class="n">ErrorMessage</span>
        <span class="p">{</span>
            <span class="k">get</span>
            <span class="p">{</span>
                <span class="c1">// elided - get from message resource type and name</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">string</span> <span class="n">ErrorMessageResourceName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="n">Type</span> <span class="n">ErrorMessageResourceType</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>


 <span class="k">public</span> <span class="k">class</span> <span class="nc">CannotUseInPasswordAttributeValuesNotAllowed</span> <span class="p">:</span> <span class="n">IAllowPassword</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">CannotUseInPasswordAttributeValuesNotAllowed</span><span class="p">(</span><span class="kt">object</span> <span class="n">viewModel</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">ViewModel</span> <span class="p">=</span> <span class="n">viewModel</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">object</span> <span class="n">ViewModel</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">IsAllowed</span><span class="p">(</span><span class="kt">string</span> <span class="n">possiblePassword</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">errorPhrases</span> <span class="p">=</span> <span class="n">GetErrorPhrases</span><span class="p">();</span>

            <span class="kt">var</span> <span class="n">errors</span> <span class="p">=</span> <span class="n">errorPhrases</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">IsBanned</span><span class="p">(</span><span class="n">possiblePassword</span><span class="p">)).</span><span class="n">Where</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="p">!</span><span class="kt">string</span><span class="p">.</span><span class="n">IsNullOrEmpty</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>

            <span class="k">return</span> <span class="n">errors</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">ErrorPhrase</span><span class="p">&gt;</span> <span class="n">GetErrorPhrases</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">viewModelProperties</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">ViewModel</span>
                                          <span class="p">.</span><span class="n">GetType</span><span class="p">()</span>
                                          <span class="p">.</span><span class="n">GetProperties</span><span class="p">();</span>

            <span class="kt">var</span> <span class="n">cannotUseProperties</span> <span class="p">=</span> <span class="n">viewModelProperties</span><span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">Attribute</span><span class="p">.</span><span class="n">IsDefined</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">CannotUseInPasswordAttribute</span><span class="p">)));</span>

            <span class="kt">var</span> <span class="n">errorPhrases</span> <span class="p">=</span> <span class="n">cannotUseProperties</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="k">new</span>
            <span class="p">{</span>
                <span class="n">PropertyValue</span> <span class="p">=</span> <span class="n">a</span><span class="p">.</span><span class="n">GetValue</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">ViewModel</span><span class="p">,</span> <span class="k">null</span><span class="p">)</span> <span class="k">as</span> <span class="kt">string</span><span class="p">,</span>
                <span class="n">ErrorMessage</span> <span class="p">=</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">GetCustomAttributes</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">CannotUseInPasswordAttribute</span><span class="p">),</span> <span class="k">false</span><span class="p">).</span><span class="n">First</span><span class="p">()</span> <span class="k">as</span> <span class="n">CannotUseInPasswordAttribute</span><span class="p">).</span><span class="n">ErrorMessage</span>
            <span class="p">})</span>
                                                  <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">PropertyValue</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                                                  <span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">ErrorPhrase</span>
                                                  <span class="p">{</span>
                                                      <span class="n">BannedPhrase</span> <span class="p">=</span> <span class="n">a</span><span class="p">.</span><span class="n">PropertyValue</span><span class="p">,</span>
                                                      <span class="n">ErrorMessage</span> <span class="p">=</span> <span class="n">a</span><span class="p">.</span><span class="n">ErrorMessage</span>
                                                  <span class="p">});</span>

            <span class="k">return</span> <span class="n">errorPhrases</span><span class="p">;</span>

        <span class="p">}</span>

        <span class="k">private</span> <span class="k">class</span> <span class="nc">ErrorPhrase</span>
        <span class="p">{</span>
            <span class="k">public</span> <span class="kt">string</span> <span class="n">BannedPhrase</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
            <span class="k">public</span> <span class="kt">string</span> <span class="n">ErrorMessage</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

            <span class="k">public</span> <span class="kt">string</span> <span class="nf">IsBanned</span><span class="p">(</span><span class="kt">string</span> <span class="n">possiblePassword</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">possiblePassword</span><span class="p">.</span><span class="n">ContainsIgnoreCase</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">BannedPhrase</span><span class="p">))</span>
                    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">ErrorMessage</span><span class="p">;</span>

                <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<p>At this point, we can update our view models to have the <code>CannotUseInPasswordAttribute</code> attribute (in our case, there&#39;s 4 of them at this point) and everything will work (assuming first name and last name get populated, which we&#39;ll deal with separately). </p>

<p>I went straight to showing the final code, but it developed over time from unit tests.  Below is one such test (using xUnit data theories)</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="na">[Theory]</span>
<span class="na">        [InlineData(&quot;$ome1234phrase&quot;)]</span>
<span class="na">        [InlineData(&quot;phrase$something&quot;)]</span>
<span class="na">        [InlineData(&quot;Containsphraseend&quot;)]</span>
<span class="na">        [InlineData(&quot;differentPHRASEcase&quot;)]</span>
        <span class="k">public</span> <span class="k">void</span> <span class="nf">ReportsError_WhenPasswordContainsValue_FromOtherAnnotatedProperty</span><span class="p">(</span><span class="kt">string</span> <span class="n">possiblePassword</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">viewModel</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SingleCannotUsePropertyViewModel</span> <span class="p">{</span> <span class="n">CannotUse</span><span class="p">=</span><span class="s">&quot;phrase&quot;</span> <span class="p">};</span>

            <span class="kt">var</span> <span class="n">sut</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CannotUseInPasswordAttributeValuesNotAllowed</span><span class="p">(</span><span class="n">viewModel</span><span class="p">);</span>

            <span class="kt">var</span> <span class="n">allowed</span> <span class="p">=</span> <span class="n">sut</span><span class="p">.</span><span class="n">IsAllowed</span><span class="p">(</span><span class="n">possiblePassword</span><span class="p">);</span>

            <span class="n">Assert</span><span class="p">.</span><span class="n">True</span><span class="p">(</span><span class="n">allowed</span><span class="p">.</span><span class="n">Count</span><span class="p">()</span> <span class="p">==</span> <span class="m">1</span><span class="p">);</span>
            <span class="n">Assert</span><span class="p">.</span><span class="n">Equal</span><span class="p">(</span><span class="n">ErrorMessages</span><span class="p">.</span><span class="n">CannotUse</span><span class="p">,</span> <span class="n">allowed</span><span class="p">.</span><span class="n">First</span><span class="p">());</span>            
        <span class="p">}</span>
</code></pre></div>
<p>This concludes how we used a custom model validator to ensure a password doesn&#39;t contain certain proscribed text.  In the next post, we will explore how we extended model binding to actually populate the necessary first and last name properties on the view models.</p>
 
	</p>
  
</div>


 
	
	<nav id="pagination">
<ul>	
    	
     
	<li>
    <a href="/page2/" title="Next Page">Next &raquo;</a>
	</li>
     
</ul>
  </nav>

</body>
</html>