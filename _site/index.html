<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Code Like A Champion</title>
		
		 <link href="/css/bootstrap.css" rel="stylesheet">
		 <link rel="icon" href="/images/logo.png" />
		 <script type="text/javascript" src="/js/jquery.js"></script>
		<script type="text/javascript" src="/js/bootstrap.js"></script>		
    <!-- Custom CSS -->
		<link href="/css/logo-nav.css" rel="stylesheet" />	
		<link href="/css/custom.css" rel="stylesheet" />
		<link rel="stylesheet" href="/css/solarized-dark.css" type="text/css"/> 

		<link href='http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic,700italic' rel='stylesheet' type='text/css' />
    </head>
    <body>
	 <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">
                    <img id="logo" src='/images/logo.png' width="125" height="125" />
                </a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/about.html">About</a>
                    </li>
					  <li>
                        <a href="#">Categories</a>
                    </li>                                       
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>	

<div class="container">
<div class="row">
 <div class="col-lg-12">		
          
	<h2><a href="/2015/04/24/autowiring-chain-composite-decorator-in-windsor.html">Registering Decorators, Composites, and Chains in Castle Windsor</a></h2>
	<div class="date">24 April 2015</div>	
	<div class="post">
	<p>As I show people Castle Windsor and how to unlock its power to write more loosely coupled components, most quickly grasp the idea of registering a single component type against a service.  That&#39;s certainly a necessary first step, but what I often see is once developers start using Windsor, the code-base explodes with violations of the Reused Abstractions Principle or the code base still contains the same tightly coupled logic that it always did.  I&#39;ve discussed in previous posts how to identify cases where a decorator, composite, or chain of responsibility can make a dramatic difference on a codebase, but I often see developers run into trouble registering components for these patterns in Windsor.  And in fact I&#39;ve had some developers tell me they abandoned that design simply because they couldn&#39;t get it registered in Windsor.  I found that wholly shocking that a tool we&#39;re using that&#39;s capable of loosening our coupling is contributing to making it worse.  To rectify that, I&#39;m going to demonstrate in this post some ways to compose these patterns in Windsor.  Definitely read to the bottom though as ultimately there is one super-easy way to do it.</p>

<h2>Chain of Responsibility</h2>

<p>In a chain of responsibility, we have some number of components that all implement the same interface and each one is connected to one (or more) of the others.  Clients call the first component in the chain and based on the logic of the overall chain sub-system, the component can take some action and/or forward it to the next component.  Below is a basic set of components for a chain that we&#39;ll use.  In our case, clients would be handed an instance of FirstInChain, which would call SecondInChain, which would call LastInChain.  </p>
<div class="highlight"><pre><code class="language-c#" data-lang="c#">
  <span class="k">public</span> <span class="k">interface</span> <span class="n">IChain</span>
    <span class="p">{</span>
        <span class="kt">string</span> <span class="nf">Get</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">class</span> <span class="nc">FirstInChain</span> <span class="p">:</span> <span class="n">IChain</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">FirstInChain</span><span class="p">(</span><span class="n">IChain</span> <span class="n">next</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">Next</span> <span class="p">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">string</span> <span class="nf">Get</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">Next</span><span class="p">.</span><span class="nf">Get</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">IChain</span> <span class="n">Next</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">class</span> <span class="nc">SecondInChain</span> <span class="p">:</span> <span class="n">IChain</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">SecondInChain</span><span class="p">(</span><span class="n">IChain</span> <span class="n">next</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">Next</span> <span class="p">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">string</span> <span class="nf">Get</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">Next</span><span class="p">.</span><span class="nf">Get</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">IChain</span> <span class="n">Next</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">class</span> <span class="nc">LastInChain</span> <span class="p">:</span> <span class="n">IChain</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">LastInChain</span><span class="p">()</span>
        <span class="p">{</span>        
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">string</span> <span class="nf">Get</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="s">"I'm done"</span><span class="p">;</span>
        <span class="p">}</span>        
    <span class="p">}</span>

</code></pre></div>
<p>The most important rule to understand for these registrations is, by default, Windsor will use the first registration for a type to determine how the object graph is composed.  Thus if we want to be given an instance of <code>FirstInChain</code>, it needs to be registered first;</p>
<div class="highlight"><pre><code class="language-c#" data-lang="c#">
    <span class="n">container</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="n">Component</span><span class="p">.</span><span class="n">For</span><span class="p">&lt;</span><span class="n">IChain</span><span class="p">&gt;().</span><span class="n">ImplementedBy</span><span class="p">&lt;</span><span class="n">FirstInChain</span><span class="p">&gt;());</span>

</code></pre></div>
<p>So now, if we call <code>container.Resolve&lt;IChain&gt;()</code>, we&#39;ll get an instance of <code>FirstInChain</code>, but since Windsor doesn&#39;t have way know what <code>FirstInChain</code> should be given (and it won&#39;t give it an instance of itself), our chain is not properly composed.  So how can we instruct Windsor about our dependencies from First-&gt;Second-&gt;Last?  Well one way is through naming each component and specifying them as dependencies.  Here&#39;s a unit test that will showcase this.  I have scrambled up the order of Second and Last to showcase that Windsor identifies the 
components using the specified dependency relationships. </p>
<div class="highlight"><pre><code class="language-c#" data-lang="c#">
  <span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
        <span class="k">public</span> <span class="k">void</span> <span class="nf">Register_ChainOfResponsiblity_UsingDependencyOnComponent_ForNamedComponents</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">var</span> <span class="n">container</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">WindsorContainer</span><span class="p">();</span>

            <span class="n">container</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="n">Component</span><span class="p">.</span><span class="n">For</span><span class="p">&lt;</span><span class="n">IChain</span><span class="p">&gt;().</span><span class="n">ImplementedBy</span><span class="p">&lt;</span><span class="n">FirstInChain</span><span class="p">&gt;().</span><span class="nf">Named</span><span class="p">(</span><span class="s">"first"</span><span class="p">)</span>
                                        <span class="p">.</span><span class="nf">DependsOn</span><span class="p">(</span><span class="n">Dependency</span><span class="p">.</span><span class="nf">OnComponent</span><span class="p">(</span><span class="s">"next"</span><span class="p">,</span> <span class="s">"second"</span><span class="p">)));</span>

            <span class="n">container</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="n">Component</span><span class="p">.</span><span class="n">For</span><span class="p">&lt;</span><span class="n">IChain</span><span class="p">&gt;().</span><span class="n">ImplementedBy</span><span class="p">&lt;</span><span class="n">LastInChain</span><span class="p">&gt;().</span><span class="nf">Named</span><span class="p">(</span><span class="s">"last"</span><span class="p">));</span>         

            <span class="n">container</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="n">Component</span><span class="p">.</span><span class="n">For</span><span class="p">&lt;</span><span class="n">IChain</span><span class="p">&gt;().</span><span class="n">ImplementedBy</span><span class="p">&lt;</span><span class="n">SecondInChain</span><span class="p">&gt;().</span><span class="nf">Named</span><span class="p">(</span><span class="s">"second"</span><span class="p">)</span>
                                        <span class="p">.</span><span class="nf">DependsOn</span><span class="p">(</span><span class="n">Dependency</span><span class="p">.</span><span class="nf">OnComponent</span><span class="p">(</span><span class="s">"next"</span><span class="p">,</span> <span class="s">"last"</span><span class="p">)));</span>

            <span class="n">var</span> <span class="n">component</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IChain</span><span class="p">&gt;();</span>

            <span class="n">var</span> <span class="n">first</span> <span class="p">=</span> <span class="n">Assert</span><span class="p">.</span><span class="n">IsType</span><span class="p">&lt;</span><span class="n">FirstInChain</span><span class="p">&gt;(</span><span class="n">component</span><span class="p">);</span>
            <span class="n">var</span> <span class="n">second</span> <span class="p">=</span> <span class="n">Assert</span><span class="p">.</span><span class="n">IsType</span><span class="p">&lt;</span><span class="n">SecondInChain</span><span class="p">&gt;(</span><span class="n">first</span><span class="p">.</span><span class="n">Next</span><span class="p">);</span>
            <span class="n">var</span> <span class="n">last</span> <span class="p">=</span> <span class="n">Assert</span><span class="p">.</span><span class="n">IsType</span><span class="p">&lt;</span><span class="n">LastInChain</span><span class="p">&gt;(</span><span class="n">second</span><span class="p">.</span><span class="n">Next</span><span class="p">);</span>            
        <span class="p">}</span>

</code></pre></div>
<p>The above is typically the first step most people make when trying to register these components.  This will work fine, but it just feels a little ugly.  How else could we do it?  Here&#39;s the amazing part of Windsor:  it will compose the graph correctly, automatically, if you just order the components the way you want them to be resolved.  </p>
<div class="highlight"><pre><code class="language-c#" data-lang="c#">
    <span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">AutoWire_ChainOfResponsiblity_BasedOnRegistrationOrder</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">var</span> <span class="n">container</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">WindsorContainer</span><span class="p">();</span>

        <span class="n">container</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="n">Component</span><span class="p">.</span><span class="n">For</span><span class="p">&lt;</span><span class="n">IChain</span><span class="p">&gt;().</span><span class="n">ImplementedBy</span><span class="p">&lt;</span><span class="n">FirstInChain</span><span class="p">&gt;(),</span>                               
                           <span class="n">Component</span><span class="p">.</span><span class="n">For</span><span class="p">&lt;</span><span class="n">IChain</span><span class="p">&gt;().</span><span class="n">ImplementedBy</span><span class="p">&lt;</span><span class="n">SecondInChain</span><span class="p">&gt;(),</span>
                           <span class="n">Component</span><span class="p">.</span><span class="n">For</span><span class="p">&lt;</span><span class="n">IChain</span><span class="p">&gt;().</span><span class="n">ImplementedBy</span><span class="p">&lt;</span><span class="n">LastInChain</span><span class="p">&gt;());</span>

        <span class="n">var</span> <span class="n">component</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IChain</span><span class="p">&gt;();</span>

        <span class="n">var</span> <span class="n">first</span> <span class="p">=</span> <span class="n">Assert</span><span class="p">.</span><span class="n">IsType</span><span class="p">&lt;</span><span class="n">FirstInChain</span><span class="p">&gt;(</span><span class="n">component</span><span class="p">);</span>
        <span class="n">var</span> <span class="n">second</span> <span class="p">=</span> <span class="n">Assert</span><span class="p">.</span><span class="n">IsType</span><span class="p">&lt;</span><span class="n">SecondInChain</span><span class="p">&gt;(</span><span class="n">first</span><span class="p">.</span><span class="n">Next</span><span class="p">);</span>
        <span class="n">var</span> <span class="n">last</span> <span class="p">=</span> <span class="n">Assert</span><span class="p">.</span><span class="n">IsType</span><span class="p">&lt;</span><span class="n">LastInChain</span><span class="p">&gt;(</span><span class="n">second</span><span class="p">.</span><span class="n">Next</span><span class="p">);</span>
    <span class="p">}</span>

</code></pre></div>
<p>The fact that Windsor will auto-wire this escaped me for quite a long time, but this is what makes Windsor so incredible: it just works.  </p>

<p>The same is also true for the other design patterns as well.</p>

<h2>Decorator</h2>

<p>A decorator is a pattern where one component of an interface type relies on another instance of that component to do its work.  For example, we may have a class that fetches records from a database and another that caches those records.  The caching component can &quot;decorate&quot; its logic on top of the other component.  Below is a sample set of components we&#39;ll work with.  We want SecondDecorator to be on top and contain an instance of FirstDecorator, which will contain an instance of BaseDecoratableService.  </p>
<div class="highlight"><pre><code class="language-c#" data-lang="c#">
 <span class="k">public</span> <span class="k">interface</span> <span class="n">IDecoratableService</span>
    <span class="p">{</span>
        <span class="kt">string</span> <span class="nf">Do</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">class</span> <span class="nc">BaseDecoratableService</span> <span class="p">:</span> <span class="n">IDecoratableService</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="nf">Do</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="kt">string</span><span class="p">.</span><span class="n">Empty</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">class</span> <span class="nc">FirstDecorator</span> <span class="p">:</span> <span class="n">IDecoratableService</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="n">IDecoratableService</span> <span class="n">inner</span><span class="p">;</span>

        <span class="k">public</span> <span class="nf">FirstDecorator</span><span class="p">(</span><span class="n">IDecoratableService</span> <span class="n">inner</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">inner</span> <span class="p">=</span> <span class="n">inner</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">string</span> <span class="nf">Do</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Concat</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="nf">Do</span><span class="p">(),</span> <span class="s">"#FIRST#"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">IDecoratableService</span> <span class="n">Inner</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">inner</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">class</span> <span class="nc">SecondDecorator</span> <span class="p">:</span> <span class="n">IDecoratableService</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="n">IDecoratableService</span> <span class="n">inner</span><span class="p">;</span>

        <span class="k">public</span> <span class="nf">SecondDecorator</span><span class="p">(</span><span class="n">IDecoratableService</span> <span class="n">inner</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">inner</span> <span class="p">=</span> <span class="n">inner</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">string</span> <span class="nf">Do</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Concat</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">inner</span><span class="p">.</span><span class="nf">Do</span><span class="p">(),</span> <span class="s">"@@SECOND@@"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">IDecoratableService</span> <span class="n">Inner</span> <span class="p">{</span> <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">inner</span><span class="p">;</span> <span class="p">}</span> <span class="p">}</span>
    <span class="p">}</span>

</code></pre></div>
<p>The registrations for Windsor to auto-wire this are almost identical to the Chain:</p>
<div class="highlight"><pre><code class="language-c#" data-lang="c#">
    <span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">AutoWire_Decorator</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">var</span> <span class="n">container</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">WindsorContainer</span><span class="p">();</span>

        <span class="n">container</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="n">Component</span><span class="p">.</span><span class="n">For</span><span class="p">&lt;</span><span class="n">IDecoratableService</span><span class="p">&gt;().</span><span class="n">ImplementedBy</span><span class="p">&lt;</span><span class="n">SecondDecorator</span><span class="p">&gt;(),</span>
                           <span class="n">Component</span><span class="p">.</span><span class="n">For</span><span class="p">&lt;</span><span class="n">IDecoratableService</span><span class="p">&gt;().</span><span class="n">ImplementedBy</span><span class="p">&lt;</span><span class="n">FirstDecorator</span><span class="p">&gt;(),</span>
                           <span class="n">Component</span><span class="p">.</span><span class="n">For</span><span class="p">&lt;</span><span class="n">IDecoratableService</span><span class="p">&gt;().</span><span class="n">ImplementedBy</span><span class="p">&lt;</span><span class="n">BaseDecoratableService</span><span class="p">&gt;());</span>       

        <span class="n">var</span> <span class="n">service</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IDecoratableService</span><span class="p">&gt;();</span>

        <span class="n">var</span> <span class="n">secondDecorator</span> <span class="p">=</span> <span class="n">Assert</span><span class="p">.</span><span class="n">IsType</span><span class="p">&lt;</span><span class="n">SecondDecorator</span><span class="p">&gt;(</span><span class="n">service</span><span class="p">);</span>
        <span class="n">var</span> <span class="n">firstDecorator</span> <span class="p">=</span> <span class="n">Assert</span><span class="p">.</span><span class="n">IsType</span><span class="p">&lt;</span><span class="n">FirstDecorator</span><span class="p">&gt;(</span><span class="n">secondDecorator</span><span class="p">.</span><span class="n">Inner</span><span class="p">);</span>
        <span class="n">var</span> <span class="n">baseService</span> <span class="p">=</span> <span class="n">Assert</span><span class="p">.</span><span class="n">IsType</span><span class="p">&lt;</span><span class="n">BaseDecoratableService</span><span class="p">&gt;(</span><span class="n">firstDecorator</span><span class="p">.</span><span class="n">Inner</span><span class="p">);</span>
    <span class="p">}</span>

</code></pre></div>
<h2>Composite</h2>

<p>A composite is a pattern where one component contains some number of instances of the same interface and depending on the logic, the composite may selectively call its contained components or call all of them.  The complication for Windsor is that it needs to supply a collection of instances and not just a single instance.  This requires us to add Windsor&#39;s CollectionResolver (if it hasn&#39;t been added previously), but otherwise is identical to the Chain and Decorator:</p>
<div class="highlight"><pre><code class="language-c#" data-lang="c#">
    <span class="k">public</span> <span class="k">interface</span> <span class="n">IComposableService</span>
    <span class="p">{</span>
        <span class="k">void</span> <span class="nf">Do</span><span class="p">(</span><span class="kt">string</span> <span class="n">s</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">class</span> <span class="nc">CompositeComposableService</span> <span class="p">:</span> <span class="n">IComposableService</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">CompositeComposableService</span><span class="p">(</span><span class="k">params</span> <span class="n">IComposableService</span><span class="p">[]</span> <span class="n">services</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">services</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentNullException</span><span class="p">(</span><span class="s">"services"</span><span class="p">);</span>

            <span class="k">this</span><span class="p">.</span><span class="n">Services</span> <span class="p">=</span> <span class="n">services</span><span class="p">.</span><span class="nf">ToList</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">Do</span><span class="p">(</span><span class="kt">string</span> <span class="n">s</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">Services</span><span class="p">.</span><span class="nf">ToList</span><span class="p">().</span><span class="nf">ForEach</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="nf">Do</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">IList</span><span class="p">&lt;</span><span class="n">IComposableService</span><span class="p">&gt;</span> <span class="n">Services</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">class</span> <span class="nc">FirstComposableService</span> <span class="p">:</span> <span class="n">IComposableService</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">void</span> <span class="nf">Do</span><span class="p">(</span><span class="kt">string</span> <span class="n">s</span><span class="p">)</span>
        <span class="p">{</span>            
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">class</span> <span class="nc">SecondComposableService</span> <span class="p">:</span> <span class="n">IComposableService</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">void</span> <span class="nf">Do</span><span class="p">(</span><span class="kt">string</span> <span class="n">s</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">AutoWire_Composite</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">var</span> <span class="n">container</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">WindsorContainer</span><span class="p">();</span>
        <span class="c1">/// Must add the CollectionResolver or it will not work.
</span>        <span class="n">container</span><span class="p">.</span><span class="n">Kernel</span><span class="p">.</span><span class="n">Resolver</span><span class="p">.</span><span class="nf">AddSubResolver</span><span class="p">(</span><span class="k">new</span> <span class="nf">CollectionResolver</span><span class="p">(</span><span class="n">container</span><span class="p">.</span><span class="n">Kernel</span><span class="p">));</span>

        <span class="n">container</span><span class="p">.</span><span class="nf">Register</span><span class="p">(</span><span class="n">Component</span><span class="p">.</span><span class="n">For</span><span class="p">&lt;</span><span class="n">IComposableService</span><span class="p">&gt;().</span><span class="n">ImplementedBy</span><span class="p">&lt;</span><span class="n">CompositeComposableService</span><span class="p">&gt;(),</span>
                           <span class="n">Component</span><span class="p">.</span><span class="n">For</span><span class="p">&lt;</span><span class="n">IComposableService</span><span class="p">&gt;().</span><span class="n">ImplementedBy</span><span class="p">&lt;</span><span class="n">FirstComposableService</span><span class="p">&gt;(),</span>
                           <span class="n">Component</span><span class="p">.</span><span class="n">For</span><span class="p">&lt;</span><span class="n">IComposableService</span><span class="p">&gt;().</span><span class="n">ImplementedBy</span><span class="p">&lt;</span><span class="n">SecondComposableService</span><span class="p">&gt;());</span>

        <span class="n">var</span> <span class="n">service</span> <span class="p">=</span> <span class="n">container</span><span class="p">.</span><span class="n">Resolve</span><span class="p">&lt;</span><span class="n">IComposableService</span><span class="p">&gt;();</span>

        <span class="n">var</span> <span class="n">composite</span> <span class="p">=</span> <span class="n">Assert</span><span class="p">.</span><span class="n">IsType</span><span class="p">&lt;</span><span class="n">CompositeComposableService</span><span class="p">&gt;(</span><span class="n">service</span><span class="p">);</span>

        <span class="n">Assert</span><span class="p">.</span><span class="nf">Equal</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="n">composite</span><span class="p">.</span><span class="n">Services</span><span class="p">.</span><span class="nf">Count</span><span class="p">());</span>
        <span class="n">Assert</span><span class="p">.</span><span class="nf">True</span><span class="p">(</span><span class="n">composite</span><span class="p">.</span><span class="n">Services</span><span class="p">.</span><span class="nf">Any</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="nf">GetType</span><span class="p">()</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="n">FirstComposableService</span><span class="p">)));</span>
        <span class="n">Assert</span><span class="p">.</span><span class="nf">True</span><span class="p">(</span><span class="n">composite</span><span class="p">.</span><span class="n">Services</span><span class="p">.</span><span class="nf">Any</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="nf">GetType</span><span class="p">()</span> <span class="p">==</span> <span class="k">typeof</span><span class="p">(</span><span class="n">SecondComposableService</span><span class="p">)));</span>
    <span class="p">}</span>

</code></pre></div>
<h2>Wrap Up</h2>

<p>So there you have it: Windsor&#39;s auto-wiring will automatically compose these 3 powerful patterns for you.  In fact it takes more work to <em>not</em> just let Windsor handle this.  Now yes, if you have some specialized resolution needs (such as you don&#39;t always want every component to be put into the Composite or something like that), then you&#39;ll have to do something extra, but otherwise, no longer any need to fear these patterns.  In a future post, I&#39;ll show how you can control conditional resolutions in Windsor as well for some more advanced scenarios. </p>
 	
	</div>
	<hr />
      
	<h2><a href="/2015/04/20/generating-mail-addresses-in-autofixture.html">Generating Mail Addresses in AutoFixture</a></h2>
	<div class="date">20 April 2015</div>	
	<div class="post">
	<p>I&#39;m wrapping up stage 1 of some modifications to AutoFixture that slightly modify new logic it has for generating a <code>MailAddress</code>.  In case you&#39;re not familiar, <code>MailAddress</code> is the standard framework type for representing email addresses.  A prior pull request to AutoFixture added a new builder that produces these mail addresses, and essentially it did so this way:</p>
<div class="highlight"><pre><code class="language-c#" data-lang="c#">
    <span class="n">var</span> <span class="n">name</span> <span class="p">=</span> <span class="n">Guid</span><span class="p">.</span><span class="nf">NewGuid</span><span class="p">().</span><span class="nf">ToString</span><span class="p">();</span>
    <span class="n">var</span> <span class="n">domain</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">fictitiousDomains</span><span class="p">[(</span><span class="kt">uint</span><span class="p">)</span><span class="n">name</span><span class="p">.</span><span class="nf">GetHashCode</span><span class="p">()</span> <span class="p">%</span><span class="m">3</span><span class="p">];</span>

    <span class="n">var</span> <span class="n">email</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Format</span><span class="p">(</span><span class="n">CultureInfo</span><span class="p">.</span><span class="n">InvariantCulture</span><span class="p">,</span> <span class="s">"{0} &lt;{0}@{1}&gt;"</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">domain</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">MailAddress</span><span class="p">(</span><span class="n">email</span><span class="p">);</span>

</code></pre></div>
<p>Basically, the <code>MailAddressGenerator</code> would create by hand two strings, one to represent the part before the &#39;@&#39; and one for the domain.  In order to ensure created email addresses couldn&#39;t slip out into the wild, the <code>ficitiousDomains</code> is simply an instance collection of safe domains (e.g. <code>example.com</code>, <code>example.org</code>, <code>example.net</code>).  However, in AutoFixture it is typically not good form to produce additional specimens when generating a certain type.  Instead, that should be deferred to the <code>ISpecimenContext</code> parameter.  In other words, something like the below would be preferable:</p>
<div class="highlight"><pre><code class="language-c#" data-lang="c#">
    <span class="n">var</span> <span class="n">name</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="n">SomeTypeRepresentingEmailName</span><span class="p">&gt;();</span>
    <span class="n">var</span> <span class="n">domain</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="n">SomeTypeRepresentingEmailDomain</span><span class="p">&gt;();</span>

</code></pre></div>
<p>The upsides to this approach:</p>

<ul>
<li>Deferring creation of those specimens back to the builder chain allows you to better customize those individual pieces</li>
<li>It is easier to reason about <code>MailAddressGenerator</code> and its logic</li>
</ul>

<p>Here&#39;s a key question:  since ultimately we need the string representation of our specimens, why don&#39;t we just ask the <code>ISpecimenContext</code> to resolve them as strings within <code>MailAddressGenerator</code>?  That would definitely work, but the risk is: suppose someone has customized string generation in AutoFixture to produce strings that result in invalid <code>MailAddress</code>es?  For that reason, we opted to use a signal type to represent the specimen we needed.  </p>

<p>First, in terms of names, an email address is made up of two parts: the local part and the domain, separated by the &#39;@&#39;.  Any cursory web search will reveal that a number of RFCs touch on the format of email addresses, but they roughly be described as:  between 1 and 64 characters in length; specific list of allowable special characters; only US ASCII characters.  That last one is fairly interesting.  Here are some local parts that Mark offered that presumably he&#39;s seen in the wild, but are prohibited per the RFC:</p>
<div class="highlight"><pre><code class="language-c#" data-lang="c#">
    <span class="p">[</span><span class="n">Theory</span><span class="p">]</span>
    <span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"ndøh"</span><span class="p">)]</span>
    <span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"ndöh"</span><span class="p">)]</span>
    <span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"åhnej"</span><span class="p">)]</span>
    <span class="p">[</span><span class="nf">InlineData</span><span class="p">(</span><span class="s">"ñoñó1234"</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">LocalParts_AreInvalid</span><span class="p">(</span><span class="kt">string</span> <span class="n">localPart</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">var</span> <span class="n">pattern</span> <span class="p">=</span> <span class="s">@"^(?!\.)(""([^""\r\\]|\\[""\r\\])*""|"</span>
                                        <span class="p">+</span> <span class="s">@"([-A-Za-z0-9!#$%&amp;'*+/=?^_`{|}~]|(?&lt;!\.)\.)*)(?&lt;!\.)$"</span><span class="p">;</span>

        <span class="n">var</span> <span class="n">invalid</span> <span class="p">=</span> <span class="n">System</span><span class="p">.</span><span class="n">Text</span><span class="p">.</span><span class="n">RegularExpressions</span><span class="p">.</span><span class="n">Regex</span><span class="p">.</span><span class="nf">IsMatch</span><span class="p">(</span><span class="n">localPart</span><span class="p">,</span> <span class="n">pattern</span><span class="p">);</span>
        <span class="n">Assert</span><span class="p">.</span><span class="nf">False</span><span class="p">(</span><span class="n">invalid</span><span class="p">);</span>    
    <span class="p">}</span>

</code></pre></div>
<p>How could that be?  How could email addresses be in use that are invalid per the RFC?  Well therein lies the rub.  The RFC says one thing, but email vendors can (and do) allow addresses to be used that violate these rules and that is their prerogative.  And in some ways that&#39;s good because the RFC is pretty restrictive as-written with basically no support for non-US characters.  That is why the typical guidance you here regarding validating email addresses is:  don&#39;t.  Don&#39;t bother.  Perhaps you do some basic syntactic validation or maybe run some regular expressions to ensure there&#39;s nothing suspicious, but otherwise the only true way to know if an email address is valid or not is to send an email message to it.  </p>

<p>That pretty quickly put me into an interesting spot.  I pitched softening the rules a bit (such as to support non-US ASCII characters, but otherwise keep the rules as-is), at which point Mark guided me to a different conclusion.  How was AutoFixture planning to use the <code>EmailAddressLocalPart</code> specimen?  As shown, we plan to request one from the <code>ISpecimenContext</code>, combine it with a domain, and then construct a <code>MailAddress</code> from it.  So for our purposes, the thing that makes an <code>EmailAddressLocalPart</code> valid is simply that <code>MailAddress</code> is able to accept it.  <code>MailAddress</code> already has a lot of validation rules that it applies in the constructor, unfortunately these are done by a <code>MailParser</code> class, which is internal within the <code>System</code> assembly so we cannot directly access it (or at least not easily).  And while we could reverse its rules, we&#39;d be forever subject to the whims of bug fixes and modifications to that logic where <code>MailAddress</code> is concerned.  For that reason, <code>EmailAddressLocalPart</code> has almost no validation in it (other than ensuring the local part constructor parameter not null and not empty) and <code>MailAddressGenerator</code> becomes:</p>
<div class="highlight"><pre><code class="language-c#" data-lang="c#">
    <span class="k">try</span> 
    <span class="p">{</span>

        <span class="n">var</span> <span class="n">localPart</span> <span class="p">=</span> <span class="n">context</span><span class="p">.</span><span class="nf">Resolve</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">EmailAddressLocalPart</span><span class="p">))</span> <span class="k">as</span> <span class="n">EmailAddressLocalPart</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">localPart</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">NoSpecimen</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">var</span> <span class="n">domain</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">fictitiousDomains</span><span class="p">[(</span><span class="kt">uint</span><span class="p">)</span><span class="n">name</span><span class="p">.</span><span class="nf">GetHashCode</span><span class="p">()</span> <span class="p">%</span><span class="m">3</span><span class="p">];</span>

        <span class="n">var</span> <span class="n">email</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="nf">Format</span><span class="p">(</span><span class="n">CultureInfo</span><span class="p">.</span><span class="n">InvariantCulture</span><span class="p">,</span> <span class="s">"{0} &lt;{0}@{1}&gt;"</span><span class="p">,</span> <span class="n">localPart</span><span class="p">,</span> <span class="n">domain</span><span class="p">);</span>    

        <span class="k">return</span> <span class="k">new</span> <span class="nf">MailAddress</span><span class="p">(</span><span class="n">email</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">ArgumentException</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">NoSpecimen</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">FormatException</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">NoSpecimen</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>
    <span class="p">}</span>

</code></pre></div>
<p>Since we&#39;re asking the <code>context</code> for an <code>EmailAddressLocalPart</code>, it needs to able to resolve it so we also have an <code>EmailAddressLocalPartGenerator</code>, which resolves a string from the <code>context</code> and produces <code>EmailAddressLocalPart</code> from it.  </p>

<p><h2>What If I&#39;ve Modified AutoFixture&#39;s String Generation?<h2></p>

<p>Let&#39;s say you&#39;re the person that has modified AutoFixture&#39;s behavior where string generation is concerned and you&#39;re also trying to use its behavior for <code>MailAddress</code>es and it&#39;s breaking - what should you do?  In case you&#39;re not familiar with AutoFixture&#39;s design, one can separate the builders it applies into two processes.  First, it has a collection of builders that it attempts to use to satisfy type requests.  These builders are in the <code>Customizations</code> property on the <code>Fixture</code> instance itself.  When AutoFixture gets a request to create a type, it first checks to see if any of these builders can satisfy it and if they do, it uses those values.  If none of the custom builders can handle the request, AutoFixture next uses its <code>Engine</code> to resolve the types.  The <code>Engine</code> is a separate collection of builders and these are what you could consider the core AutoFixture builders that most everyone relies on without thinking about it.  The generators I discussed above, <code>MailAddressGenerator</code> and <code>EmailAddressLocalPartGenerator</code>, are both hooked into the <code>Engine</code> automatically so are always available.  But you as the user are free to define your own builder that will resolve <code>MailAddress</code> or <code>EmailAddressLocalPart</code> however you see fit to work around a case when string generation causes mail address validation failures.  This seems fairly unlikely, but given the goal of AutoFixture being widely applicable to many situations, it is set up to support these needs, albeit you take on a bit more of the burden yourself.  </p>
 	
	</div>
	<hr />
  



 
	</div>
</div>
</div>
<ul class="pager">
 	
	  
	 <li>
    <a  href="/page2/" title="Older">Older &raquo;</a>
	</li>
     
</ul>		
   


  
	
</body>
</html>