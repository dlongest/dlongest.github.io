<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <!--<title>Home</title>-->
		<link rel="stylesheet" href="/css/normalize.min.css" type="text/css" />
		<link rel="stylesheet" href="/css/solarized-dark.css" type="text/css"/>
		<link rel="stylesheet" href="/css/main.css" type="text/css" />
		<link rel="stylesheet" href="/css/header.css" type="text/css"/>
		<link href='http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic,700italic' rel='stylesheet' type='text/css' />
    </head>
    <body>
	<div id="header">
	<a href="http://dlongest.github.io/" title="Dan Longest's Blog Homepage"><img id="logo" src='/images/logo.png' /></a>
	<nav>
	  <ul>
	    <li><a href="posts.html">Posts</a></li>
	    <li><a href="#">Projects</a></li>
	    <li><a href="#">About</a></li>
	    <li><a href="#">Contact</a></li>
	  </ul>
    </nav>
	</div>

    <div class="maincontent">
      
	<h2>Writing a Custom MVC Model Validator</h2>
	<em>14 December 2014</em>
	<p>The power of ASP.NET MVC is how extensible the framework is, but with this comes a challenge:  in certain cases as a developer you know (or have a feeling) that there is an extension point, but how do you find and use the right one?  In a series of posts, I will explore the myriad extension points in MVC from the perspective of a project I&#39;ve been working on for a few months.  Like most development, every situation has an almost limitless number of options for accomplishing it, but with regards to extending MVC in my experience there is often one &quot;best&quot; choice, the key is being aware of it.  </p>

<p>To establish some context, here&#39;s the project: a login application.  There are thousands (or millions) of these available so why would we be writing our own?  I work for a not-for-profit company and we made the decision to license a popular identity access management (IAM) platform from a vendor and partner with a second company to implement and support it for us.  Initially, there had been no development work planned on our side at all: the implementer would take care of all of it with an out-of-the-box login application configured against various cloud services (provided by the solution vendor, but running in the implementer&#39;s cloud).  However, the OOTB application was not responsive, which was a big deal for us so the decision was made for us to write our own.  Conceptually, this seemed straightforward enough: the login application would (in theory) simply make calls to either a REST service (for logging in) or a SOAP service (for most other identity functions, password resets and the like).  However, over time our custom login application began to accrue more and more functionality as the implementer struggled to support our requirements within the vendor solution.  It is this difficulty supporting some requirements that led us to extending the framework in various ways. </p>

<p>There are plenty of other posts and articles out on the web that describe the order of certain actions in the framework and I won&#39;t go into those in detail, but the key is this order:</p>

<ul>
<li>Model binding (which includes model validation)</li>
<li>Filters (authorization, action, result)</li>
</ul>

<p>Model binding is the set of components that populate a model (which is often a view model, but can be any type which is the parameter for a controller action), using values pulled from the value provider.  A value provider is an abstraction over the HTTP request itself plus whatever custom value providers have been defined.  Under the hood there are several different default providers (one for querystring values, one for posted data, etc), but they are gathered together into a composite pattern (so if you look at the ControllerContext.Controller.ValueProvider, it is a single instance).  As the binding progresses, the model binder fetches model validators out of the framework&#39;s static <code>ModelValidatorProviders</code> collection and executes each validator.  An individual model validator looks at some part of the model that it cares about and generates a <code>ModelValidationResult</code> containing error text if the validation fails that the model binder then writes into the model state error. </p>

<p>So here&#39;s the situation: like most enterprises, we have specific rules governing a user&#39;s password, but the vendor IAM platform simply could not be configured to support our custom rules in concert with disabling certain out of the box rules we didn&#39;t want to use (yes, very bizarre, I agree).  What are our custom rules? </p>

<ul>
<li>Can&#39;t use certain banned phrases in the password</li>
<li>Can&#39;t use your first name or last name anywhere in the password</li>
<li>Password must be between 8 and 30 characters long</li>
<li>Password must have a lowercase character, an uppercase character, and a number</li>
<li>Password cannot have certain special characters (or said another way, we only support a limited numuber of non-alphanumeric characters)</li>
</ul>

<p>A few of the rules are supported trivially with model annotations, such as the length (using <code>StringLength</code>) and acceptable alphanumeric characters (using custom RegEx attributes if nothing else).  However, the restrictions on first name and last name and banned phrases are much more difficult, especially: where do the first name and last name come from?  Where do the banned phrases come from?  An attribute could be written to do this, but it would almost definitely not be unit testable. </p>

<p>It feels in this case like model validation is still the right mechanism to use: it&#39;s built into the framework and will run for us automatically so let&#39;s start by writing a model validator to validate the password.  </p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"> <span class="k">public</span> <span class="k">class</span> <span class="nc">PasswordValidator</span> <span class="p">:</span> <span class="n">ModelValidator</span>
    <span class="p">{</span>

        <span class="k">public</span> <span class="nf">PasswordValidator</span><span class="p">(</span><span class="n">IAllowPassword</span> <span class="n">allowPassword</span><span class="p">,</span> <span class="n">ModelMetadata</span> <span class="n">metadata</span><span class="p">,</span>
                                 <span class="n">ControllerContext</span> <span class="n">context</span><span class="p">)</span>
            <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">metadata</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">PasswordProperty</span> <span class="p">=</span> <span class="n">metadata</span><span class="p">.</span><span class="n">ModelType</span><span class="p">.</span><span class="n">GetProperties</span><span class="p">().</span><span class="n">First</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">Attribute</span><span class="p">.</span><span class="n">IsDefined</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">PasswordFormatAttribute</span><span class="p">)));</span>
            <span class="k">this</span><span class="p">.</span><span class="n">Password</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">PasswordProperty</span><span class="p">.</span><span class="n">GetValue</span><span class="p">(</span><span class="n">metadata</span><span class="p">.</span><span class="n">Model</span><span class="p">,</span> <span class="k">null</span><span class="p">)</span> <span class="k">as</span> <span class="kt">string</span><span class="p">;</span>
            <span class="k">this</span><span class="p">.</span><span class="n">AllowPasswordPolicy</span> <span class="p">=</span> <span class="n">allowPassword</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">PropertyInfo</span> <span class="n">PasswordProperty</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="kt">string</span> <span class="n">Password</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="n">IAllowPassword</span> <span class="n">AllowPasswordPolicy</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>


        <span class="k">public</span> <span class="k">override</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">ModelValidationResult</span><span class="p">&gt;</span> <span class="n">Validate</span><span class="p">(</span><span class="kt">object</span> <span class="n">container</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">try</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">notAllowedReasons</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">AllowPasswordPolicy</span><span class="p">.</span><span class="n">IsAllowed</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">Password</span><span class="p">);</span>

                <span class="k">return</span> <span class="n">notAllowedReasons</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">CreateResult</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>

            <span class="p">}</span>
            <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">Enumerable</span><span class="p">.</span><span class="n">Empty</span><span class="p">&lt;</span><span class="n">ModelValidationResult</span><span class="p">&gt;();</span>
            <span class="p">}</span>
        <span class="p">}</span>    


        <span class="k">protected</span> <span class="n">ModelValidationResult</span> <span class="nf">CreateResult</span><span class="p">(</span><span class="kt">string</span> <span class="n">message</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">ModelValidationResult</span>
            <span class="p">{</span>
                <span class="n">MemberName</span> <span class="p">=</span> <span class="s">&quot;Password&quot;</span><span class="p">,</span>
                <span class="n">Message</span> <span class="p">=</span> <span class="n">message</span>
            <span class="p">};</span>
        <span class="p">}</span>
    <span class="p">}</span>   
</code></pre></div>
<p>The <code>PasswordValidator</code> relies on a collection of <code>IAllowPassword</code> rules to decide if a given password is acceptable or not.  The validator is created by a custom instance of <code>ModelValidatorProvider</code> which in this case looks up the banned phrsaes from the web.config and then instantiates the other IAllowPassword instances:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">WebConfigPasswordComplexityModelValidatorProvider</span> <span class="p">:</span> <span class="n">ModelValidatorProvider</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">bannedPhrases</span><span class="p">;</span>        

        <span class="k">public</span> <span class="nf">WebConfigPasswordComplexityModelValidatorProvider</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">config</span> <span class="p">=</span> <span class="n">ConfigurationManager</span><span class="p">.</span><span class="n">GetSection</span><span class="p">(</span><span class="s">&quot;passwordComplexityRules&quot;</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="p">==</span><span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="n">bannedPhrases</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">passwordConfig</span> <span class="p">=</span> <span class="p">(</span><span class="n">PasswordComplexityRulesConfigurationSection</span><span class="p">)</span><span class="n">config</span><span class="p">;</span>

                <span class="k">this</span><span class="p">.</span><span class="n">bannedPhrases</span> <span class="p">=</span> <span class="n">passwordConfig</span><span class="p">.</span><span class="n">BannedPhrases</span>
                                       <span class="p">.</span><span class="n">Cast</span><span class="p">&lt;</span><span class="n">PasswordComplexityBannedPhraseConfigurationElement</span><span class="p">&gt;()</span>
                                       <span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">Phrase</span><span class="p">);</span>
            <span class="p">}</span>           
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">override</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">ModelValidator</span><span class="p">&gt;</span> <span class="n">GetValidators</span><span class="p">(</span><span class="n">ModelMetadata</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">ControllerContext</span> <span class="n">context</span><span class="p">)</span>
        <span class="p">{</span>              
            <span class="k">if</span> <span class="p">(!</span><span class="k">typeof</span><span class="p">(</span><span class="n">AutomaticReturnViewModel</span><span class="p">).</span><span class="n">IsAssignableFrom</span><span class="p">(</span><span class="n">metadata</span><span class="p">.</span><span class="n">ModelType</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">Enumerable</span><span class="p">.</span><span class="n">Empty</span><span class="p">&lt;</span><span class="n">ModelValidator</span><span class="p">&gt;();</span>

            <span class="k">if</span> <span class="p">(!</span><span class="n">metadata</span><span class="p">.</span><span class="n">ModelType</span><span class="p">.</span><span class="n">GetProperties</span><span class="p">().</span><span class="n">Any</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">Attribute</span><span class="p">.</span><span class="n">IsDefined</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">PasswordFormatAttribute</span><span class="p">))))</span>
                <span class="k">return</span> <span class="n">Enumerable</span><span class="p">.</span><span class="n">Empty</span><span class="p">&lt;</span><span class="n">ModelValidator</span><span class="p">&gt;();</span>

            <span class="k">return</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">ModelValidator</span><span class="p">&gt;</span>
            <span class="p">{</span>
                <span class="k">new</span> <span class="nf">PasswordValidator</span><span class="p">(</span><span class="k">new</span> <span class="n">CompositeAllowPassword</span><span class="p">(</span>
                                        <span class="k">new</span> <span class="nf">CannotUseInPasswordAttributeValuesNotAllowed</span><span class="p">(</span><span class="n">metadata</span><span class="p">.</span><span class="n">Model</span><span class="p">),</span>
                                        <span class="k">new</span> <span class="nf">PasswordWithBannedPhrasesNotAllowed</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">bannedPhrases</span><span class="p">)),</span> <span class="n">metadata</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
            <span class="p">};</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<p>Our custom ModelValidatorProvider is hooked into the framework in the Global.asax:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"> <span class="n">ModelValidatorProviders</span><span class="p">.</span><span class="n">Providers</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">WebConfigPasswordComplexityModelValidatorProvider</span><span class="p">());</span>
</code></pre></div>
<p>Now for the actual <code>IAllowPassword</code> implementations.</p>

<p>First, <code>PasswordWithBannedPhrasesNotAllowed</code> takes a collection of banned phrases (simple strings) and just verifies if the possiblePassword contains any of them.  </p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="k">public</span> <span class="k">class</span> <span class="nc">PasswordWithBannedPhrasesNotAllowed</span> <span class="p">:</span> <span class="n">IAllowPassword</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">PasswordWithBannedPhrasesNotAllowed</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">bannedPhrases</span><span class="p">)</span>
            <span class="p">:</span> <span class="k">this</span><span class="p">(</span><span class="n">bannedPhrases</span><span class="p">,</span> <span class="n">ControllerResources</span><span class="p">.</span><span class="n">Password_Phrase_NotAllowed</span><span class="p">)</span>
        <span class="p">{</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="nf">PasswordWithBannedPhrasesNotAllowed</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">bannedPhrases</span><span class="p">,</span> <span class="kt">string</span> <span class="n">errorMessage</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">BannedPhrases</span> <span class="p">=</span> <span class="n">bannedPhrases</span> <span class="p">??</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>
            <span class="k">this</span><span class="p">.</span><span class="n">ErrorMessage</span> <span class="p">=</span> <span class="n">errorMessage</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">BannedPhrases</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">IsAllowed</span><span class="p">(</span><span class="kt">string</span> <span class="n">possiblePassword</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">BannedPhrases</span><span class="p">.</span><span class="n">Any</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">possiblePassword</span><span class="p">.</span><span class="n">ContainsIgnoreCase</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
                <span class="k">return</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="p">{</span> <span class="k">this</span><span class="p">.</span><span class="n">ErrorMessage</span> <span class="p">};</span>

            <span class="k">return</span> <span class="n">Enumerable</span><span class="p">.</span><span class="n">Empty</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;();</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">string</span> <span class="n">ErrorMessage</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<p>Next is the more interesting rule that a password cannot contain a first name or last name.  The challenging part of this instance is: how does it know where to find the first name and last name?  Does it have to look it up or is the field available to it somewhere (such as on the model)?  Can it work in a consistent way across any view model that has a password (which, for us, is ChangePasswordViewModel, ResetPasswordViewModel, and CreateAccountViewModel, as all of them allow a user to input a new password)?  </p>

<p>Here&#39;s one approach.  First, let&#39;s say that the view model needs to have the first name and last name that should be used for validation.  In some cases, the user is entering the first name and last name when they enter a new password so it&#39;s a natural fit (e.g. creating an account).  In other cases, first name and last name aren&#39;t entered by the user so we must figure out some way to populate them.  That may seem like a hardship (and a later post will outline a way we did that), but think about the component we&#39;re writing currently:  a model validator.  The validator does not (and should not) care how a view model is bound: its only precondition is the view model has been completely bound and is ready to be validated.  So we will temporarily shelve the concerns about how we&#39;ll put first name and last name into the model and just assume they can be put in there for us by some model binder.  </p>

<p>That leaves only one final issue:  how should our rule know that a given field is a first name or last name field?  One way is to provide it with property names (or property names mapped to a view model type) and that would work fine.  It would be implicit though while most model binding and validation is driven explicitly via annotations (of course, the banned phrase validator above is implicit).  Let&#39;s define a <code>CannotUseInPasswordAttribute</code> (with no behavior) that can be placed on any property on the view model that indicates it cannot be part of the password, then have our rule simply find those properties with that annotation and voila, it knows what fields are ineligible.  Each particular annotation will include the error message that should be written into the model state error (so the message for first name and last name could be different).  </p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"> <span class="k">public</span> <span class="k">class</span> <span class="nc">CannotUseInPasswordAttribute</span> <span class="p">:</span> <span class="n">Attribute</span> 
    <span class="p">{</span>
        <span class="k">private</span> <span class="kt">string</span> <span class="n">errorMessage</span><span class="p">;</span>

        <span class="k">public</span> <span class="kt">string</span> <span class="n">ErrorMessage</span>
        <span class="p">{</span>
            <span class="k">get</span>
            <span class="p">{</span>
                <span class="c1">// elided - get from message resource type and name</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">string</span> <span class="n">ErrorMessageResourceName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="n">Type</span> <span class="n">ErrorMessageResourceType</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>


 <span class="k">public</span> <span class="k">class</span> <span class="nc">CannotUseInPasswordAttributeValuesNotAllowed</span> <span class="p">:</span> <span class="n">IAllowPassword</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">CannotUseInPasswordAttributeValuesNotAllowed</span><span class="p">(</span><span class="kt">object</span> <span class="n">viewModel</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="n">ViewModel</span> <span class="p">=</span> <span class="n">viewModel</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">object</span> <span class="n">ViewModel</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">IsAllowed</span><span class="p">(</span><span class="kt">string</span> <span class="n">possiblePassword</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">errorPhrases</span> <span class="p">=</span> <span class="n">GetErrorPhrases</span><span class="p">();</span>

            <span class="kt">var</span> <span class="n">errors</span> <span class="p">=</span> <span class="n">errorPhrases</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">IsBanned</span><span class="p">(</span><span class="n">possiblePassword</span><span class="p">)).</span><span class="n">Where</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="p">!</span><span class="kt">string</span><span class="p">.</span><span class="n">IsNullOrEmpty</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>

            <span class="k">return</span> <span class="n">errors</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">ErrorPhrase</span><span class="p">&gt;</span> <span class="n">GetErrorPhrases</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">viewModelProperties</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">ViewModel</span>
                                          <span class="p">.</span><span class="n">GetType</span><span class="p">()</span>
                                          <span class="p">.</span><span class="n">GetProperties</span><span class="p">();</span>

            <span class="kt">var</span> <span class="n">cannotUseProperties</span> <span class="p">=</span> <span class="n">viewModelProperties</span><span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">Attribute</span><span class="p">.</span><span class="n">IsDefined</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="k">typeof</span><span class="p">(</span><span class="n">CannotUseInPasswordAttribute</span><span class="p">)));</span>

            <span class="kt">var</span> <span class="n">errorPhrases</span> <span class="p">=</span> <span class="n">cannotUseProperties</span><span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="k">new</span>
            <span class="p">{</span>
                <span class="n">PropertyValue</span> <span class="p">=</span> <span class="n">a</span><span class="p">.</span><span class="n">GetValue</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">ViewModel</span><span class="p">,</span> <span class="k">null</span><span class="p">)</span> <span class="k">as</span> <span class="kt">string</span><span class="p">,</span>
                <span class="n">ErrorMessage</span> <span class="p">=</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">GetCustomAttributes</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">CannotUseInPasswordAttribute</span><span class="p">),</span> <span class="k">false</span><span class="p">).</span><span class="n">First</span><span class="p">()</span> <span class="k">as</span> <span class="n">CannotUseInPasswordAttribute</span><span class="p">).</span><span class="n">ErrorMessage</span>
            <span class="p">})</span>
                                                  <span class="p">.</span><span class="n">Where</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">PropertyValue</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                                                  <span class="p">.</span><span class="n">Select</span><span class="p">(</span><span class="n">a</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="n">ErrorPhrase</span>
                                                  <span class="p">{</span>
                                                      <span class="n">BannedPhrase</span> <span class="p">=</span> <span class="n">a</span><span class="p">.</span><span class="n">PropertyValue</span><span class="p">,</span>
                                                      <span class="n">ErrorMessage</span> <span class="p">=</span> <span class="n">a</span><span class="p">.</span><span class="n">ErrorMessage</span>
                                                  <span class="p">});</span>

            <span class="k">return</span> <span class="n">errorPhrases</span><span class="p">;</span>

        <span class="p">}</span>

        <span class="k">private</span> <span class="k">class</span> <span class="nc">ErrorPhrase</span>
        <span class="p">{</span>
            <span class="k">public</span> <span class="kt">string</span> <span class="n">BannedPhrase</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
            <span class="k">public</span> <span class="kt">string</span> <span class="n">ErrorMessage</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

            <span class="k">public</span> <span class="kt">string</span> <span class="nf">IsBanned</span><span class="p">(</span><span class="kt">string</span> <span class="n">possiblePassword</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">possiblePassword</span><span class="p">.</span><span class="n">ContainsIgnoreCase</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">BannedPhrase</span><span class="p">))</span>
                    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="n">ErrorMessage</span><span class="p">;</span>

                <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<p>At this point, we can update our view models to have the <code>CannotUseInPasswordAttribute</code> attribute (in our case, there&#39;s 4 of them at this point) and everything will work (assuming first name and last name get populated, which we&#39;ll deal with separately). </p>

<p>I went straight to showing the final code, but it developed over time from unit tests.  Below is one such test (using xUnit data theories)</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp"><span class="na">[Theory]</span>
<span class="na">        [InlineData(&quot;$ome1234phrase&quot;)]</span>
<span class="na">        [InlineData(&quot;phrase$something&quot;)]</span>
<span class="na">        [InlineData(&quot;Containsphraseend&quot;)]</span>
<span class="na">        [InlineData(&quot;differentPHRASEcase&quot;)]</span>
        <span class="k">public</span> <span class="k">void</span> <span class="nf">ReportsError_WhenPasswordContainsValue_FromOtherAnnotatedProperty</span><span class="p">(</span><span class="kt">string</span> <span class="n">possiblePassword</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">viewModel</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SingleCannotUsePropertyViewModel</span> <span class="p">{</span> <span class="n">CannotUse</span><span class="p">=</span><span class="s">&quot;phrase&quot;</span> <span class="p">};</span>

            <span class="kt">var</span> <span class="n">sut</span> <span class="p">=</span> <span class="k">new</span> <span class="n">CannotUseInPasswordAttributeValuesNotAllowed</span><span class="p">(</span><span class="n">viewModel</span><span class="p">);</span>

            <span class="kt">var</span> <span class="n">allowed</span> <span class="p">=</span> <span class="n">sut</span><span class="p">.</span><span class="n">IsAllowed</span><span class="p">(</span><span class="n">possiblePassword</span><span class="p">);</span>

            <span class="n">Assert</span><span class="p">.</span><span class="n">True</span><span class="p">(</span><span class="n">allowed</span><span class="p">.</span><span class="n">Count</span><span class="p">()</span> <span class="p">==</span> <span class="m">1</span><span class="p">);</span>
            <span class="n">Assert</span><span class="p">.</span><span class="n">Equal</span><span class="p">(</span><span class="n">ErrorMessages</span><span class="p">.</span><span class="n">CannotUse</span><span class="p">,</span> <span class="n">allowed</span><span class="p">.</span><span class="n">First</span><span class="p">());</span>            
        <span class="p">}</span>
</code></pre></div>
<p>This concludes how we used a custom model validator to ensure a password doesn&#39;t contain certain proscribed text.  In the next post, we will explore how we extending model binding to actually populate the necessary first and last name properties on the view models.</p>
 
	</p>
      
	<h2>Introduction to Custom Specimen Builders in AutoFixture</h2>
	<em>20 July 2014</em>
	<p>It is no secret at work that I greatly admire Mark Seemann.  Anyone that comes to me and asks about software design I steer them right to his book &quot;Dependency Injection in .NET&quot;.  In some respects, the title does it a bit of a disservice as at least half of it discusses some critical component design practices that apply regardless of whether one wants to use dependency injection.  Don&#39;t get me wrong, he covers dependency injection quite comprehensively, but there&#39;s a lot more to DI than just picking a container.  Beyond his book, Mark is an incredibly accessible guy in a couple respects.  One, he blogs pretty regularly and has a lot of incredible posts on design, I find myself going back to them again and again.  And two, he is the author of AutoFixture, which needs almost no introduction in the .NET world.  And it is this library that is the subject of this post. </p>

<p>When I explain AutoFixture to other developers, I start by emphasizing its most straightforward use: when writing unit tests, it will provide you with test data with almost no setup, as if by magic.  Whether you needs integers or strings or collections or even complex objects, AutoFixture will provide them to you in a semi-random fashion.  Within the AutoFixture codebase, the components that handle creation of some value are termed specimen builders and they inherit <code>ISpecimenBuilder</code>.  A few common examples:  </p>

<ul>
<li><code>Int32Generator</code> is the specimen builder that generates integers, beginning at 1 and incrementing by 1 for each subsequent integer that the fixture creates.<br></li>
<li><code>StringGenerator</code> generates strings and the default randomization is to append a GUID to the name of the property or field</li>
<li><code>RandomRangedNumberGenerator</code> generates a random number within a given range, but doesn&#39;t repeat numbers in that range until all values have been used (shameless plug: I submitted this to AutoFixture)</li>
</ul>

<p>And of course there are plenty more beyond that that do a variety of things.  Mark has an older but still valid post from 2010 on how to approach creating a custom specimen builder, but I think there&#39;s some nuances to it that aren&#39;t entirely clear to new users of AutoFixture.  I know when I introduced AutoFixture at work we used it in a sub-optimal manner because it wasn&#39;t always clear how to best customize it for certain situations and I want to save others some effort in the future since there isn&#39;t always time to dig into new libraries like one would hope.  This in no way takes away from how incredible AutoFixture is or how responsive Mark and others (Adam Chester and Nikos Baxevanis among them) are to questions about it on Stack Overflow or elsewhere, just my attempt to contribute some first-hand experience and perspective.</p>

<p>The <code>ISpecimenBuilder</code> interface has the following signature (taken directly from the AutoFixture codebase):</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">    <span class="k">public</span> <span class="k">interface</span> <span class="n">ISpecimenBuilder</span>
    <span class="p">{</span>        
        <span class="kt">object</span> <span class="nf">Create</span><span class="p">(</span><span class="kt">object</span> <span class="n">request</span><span class="p">,</span> <span class="n">ISpecimenContext</span> <span class="n">context</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>
<p>Here, <code>request</code> is <em>something</em> that needs to be created (and I&#39;ll come back to that in a minute).  The <code>context</code> can be used if necessary to generate other values from the fixture, but is not always needed.  For example, <code>Int32Generator</code> has no need of the <code>context</code> as it contains all the knowledge for satisfying its creation goals.  But suppose you&#39;re creating a specimen builder for a complex type and in the course of that, you want AutoFixture to provide some value (of any type)?  In that case you can use the <code>context</code> to obtain it (I&#39;m intentionally omitting why you get <code>ISpecimenContext</code> and not <code>IFixture</code>).  </p>

<p>Request is ambiguously typed as <code>object</code> - what is it?  Typically, <code>request</code> is one of:</p>

<ul>
<li>A <code>Type</code></li>
<li>A <code>PropertyInfo</code></li>
<li>A <code>ParameterInfo</code></li>
</ul>

<p>And that brings us finally to the point of this post:  why on earth is that and what does it mean for us trying to create a custom specimen builder?</p>

<p>We&#39;ll start with the most obvious, Type.  At the most basic level, use of AutoFixture generally looks like:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">    <span class="kt">var</span> <span class="n">fixture</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Fixture</span><span class="p">();</span>            
    <span class="kt">var</span> <span class="n">contact</span> <span class="p">=</span> <span class="n">fixture</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="n">Contact</span><span class="p">&gt;();</span>
</code></pre></div>
<p>We create a Fixture, then we ask it for the type <code>Contact</code>, which is defined as:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">     <span class="k">public</span> <span class="k">class</span> <span class="nc">Contact</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">Contact</span><span class="p">(</span><span class="kt">string</span> <span class="n">personId</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">PersonId</span> <span class="p">=</span> <span class="n">personId</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">string</span> <span class="n">PersonId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span>  <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<p>AutoFixture now attempts to satisfy the request for a contact by running it through a variety of specimen builders in an implementation of the powerful chain of responsibility pattern.  The chain in this case is (among other things) a collection of specimen builders that individually assess whether they are capable of providing a value of type <code>Contact</code>.  The request to create it falls through each builder in the chain until one finally returns an actual <code>Contact</code> (each returns a <code>NoSpecimen</code> if it cannot handle the request).  But what does it mean to create a Contact?  </p>

<p>As shown, AutoFixture will find that Contact has one constructor and that this constructor takes a string.  So AutoFixture will automatically attempt to resolve creation of a string, then use that to create the <code>Contact</code> via its constructor.  This would be true regardless of how many dependencies the constructor had or their type.  And if there are multiple constructors, AutoFixture selects among them (by default, taking the one with the fewest parameters).  So from that view, AutoFixture creating an instance of an arbitrary complex type is simply the creation of any dependencies of that type until the entire graph is constructed. </p>

<p>Now let&#39;s say for the sake of argument that PersonId, despite being typed as a string, is actually numeric.  We&#39;ve already seen earlier that AutoFixture, by default, will make strings whose value are the property name and a GUID so we know that the default is not going to work for us here.  The first and easiest approach to this is:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">    <span class="kt">var</span> <span class="n">fixture</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Fixture</span><span class="p">();</span>
    <span class="n">fixture</span><span class="p">.</span><span class="n">Register</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="s">&quot;12345678&quot;</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">contact</span> <span class="p">=</span> <span class="n">fixture</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="n">Contact</span><span class="p">&gt;();</span>
</code></pre></div>
<p>This solves one problem (PersonId on the Contact will be &quot;12345678&quot;) <em>except</em> this will cause AutoFixture to use &quot;12345678&quot; for every string it creates.  So we&#39;ve overreached a bit here.  Of course we could use some method that generates a random integer and uses that instead of a hard-coded one, but again, it will use that random numeric string everywhere.  At some point, it might occur to us &quot;What if we could customize the creation of Contact as a whole instead of at the string level?&quot;  Enter a custom specimen builder.  </p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">    <span class="k">public</span> <span class="k">class</span> <span class="nc">ContactGenerator</span> <span class="p">:</span> <span class="n">ISpecimenBuilder</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">object</span> <span class="nf">Create</span><span class="p">(</span><span class="kt">object</span> <span class="n">request</span><span class="p">,</span> <span class="n">ISpecimenContext</span> <span class="n">context</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">type</span> <span class="p">=</span> <span class="n">request</span> <span class="k">as</span> <span class="n">Type</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
                <span class="k">return</span> <span class="k">new</span> <span class="nf">NoSpecimen</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="p">!=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">Contact</span><span class="p">))</span>
                <span class="k">return</span> <span class="k">new</span> <span class="nf">NoSpecimen</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>

            <span class="k">return</span> <span class="k">new</span> <span class="nf">Contact</span><span class="p">(</span><span class="s">&quot;12345678&quot;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<p>So here, what is <code>request</code>?  Well remember, we&#39;re asking the Fixture to resolve <code>Contact</code> for us and our specimen builder&#39;s purpose is to create an entire <code>Contact</code> so <code>request</code> would be a Type.  But it&#39;s not just any arbitrary <code>Type</code>, our builder would only care about <code>Contact</code>.  The builder above follows a standard form:  attempt to cast <code>request</code> into what it&#39;s able to operate on, ensure that we did indeed get a request we can handle (returning <code>NoSpecimen</code> if we can&#39;t), and then create our desired instance.  In the above, we&#39;re hardcoding &quot;12345678&quot; as the parameter to the <code>Contact</code> constructor.  What if we want AutoFixture to make a random integer for us to use for that purpose?  Simple enough to use the <code>context</code> to resolve that for us:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">    <span class="k">return</span> <span class="k">new</span> <span class="nf">Contact</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;().</span><span class="n">ToString</span><span class="p">());</span>
</code></pre></div>
<p>Now we&#39;re able to create a <code>Contact</code> with a properly numeric PersonId whose value is being provided by the fixture&#39;s normal integer rules.  The final step is to tell AutoFixture about the specimen builder:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">    <span class="n">fixture</span><span class="p">.</span><span class="n">Customizations</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">ContactGenerator</span><span class="p">());</span>
</code></pre></div>
<p>Now you have a specimen builder capable of constructing a given type for you and perhaps that is sufficient for your needs.  But let&#39;s say <code>Contact</code> gets a bit more interesting:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">    <span class="k">public</span> <span class="k">class</span> <span class="nc">Contact</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="kt">string</span> <span class="n">personId</span><span class="p">;</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="kt">string</span> <span class="n">firstName</span><span class="p">;</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="kt">string</span> <span class="n">lastName</span><span class="p">;</span>

        <span class="k">public</span> <span class="nf">Contact</span><span class="p">(</span><span class="kt">string</span> <span class="n">personId</span><span class="p">,</span> <span class="kt">string</span> <span class="n">firstName</span><span class="p">,</span> <span class="kt">string</span> <span class="n">lastName</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">/// elided</span>
        <span class="p">}</span>

        <span class="c1">/// normal get; private set; property declarations  </span>
    <span class="p">}</span>
</code></pre></div>
<p>So here our contact is a PersonId (using the same numeric string rules as before), a level (an integer from 1 to 3), and first name and last name.  Let&#39;s assume that names are not particularly interesting, but there are valid reasons to use different levels in your testing, but again, they must be constrained within a specified range.  </p>

<p>We can let AutoFixture just provide us with random strings for the names, but we cannot simply ask it for an integer for level as we must constrain it to a certain range.  How can we support that?  Of course one way is to extend our <code>ContactGenerator</code> class to now include rules for constraining levels.  That might look like:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">     <span class="k">return</span> <span class="k">new</span> <span class="nf">Contact</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;().</span><span class="n">ToString</span><span class="p">(),</span>
                               <span class="n">context</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(),</span> <span class="n">context</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(),</span>
                               <span class="k">new</span> <span class="nf">Random</span><span class="p">().</span><span class="n">Next</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">3</span><span class="p">));</span>
</code></pre></div>
<p>This seems to work fine, but something about it feels a little off.  For one, we&#39;ve got a lot of rules about our system and its valid inputs buried within this builder instead of having them be explicit.  Sometimes, this suggests the need to make a concept more explicit, possibly by introducing <code>PersonId</code> and <code>Level</code> as value objects that properly communicate our intent.  Let&#39;s say we introduce such types as shown below:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">    <span class="k">public</span> <span class="k">class</span> <span class="nc">PersonId</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">PersonId</span><span class="p">(</span><span class="kt">string</span> <span class="n">personId</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(!</span><span class="n">personId</span><span class="p">.</span><span class="n">IsNumeric</span><span class="p">())</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="s">&quot;personId&quot;</span><span class="p">);</span>

            <span class="k">this</span><span class="p">.</span><span class="n">Id</span> <span class="p">=</span> <span class="n">personId</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">string</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">class</span> <span class="nc">ContactLevel</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">ContactLevel</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="p">&lt;=</span> <span class="m">0</span> <span class="p">||</span> <span class="n">level</span> <span class="p">&gt;</span> <span class="m">3</span><span class="p">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="s">&quot;level&quot;</span><span class="p">);</span>

            <span class="k">this</span><span class="p">.</span><span class="n">Level</span> <span class="p">=</span> <span class="n">level</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">int</span> <span class="n">Level</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<p>That changes our <code>Contact</code> constructor to:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">    <span class="k">public</span> <span class="nf">Contact</span><span class="p">(</span><span class="n">PersonId</span> <span class="n">personId</span><span class="p">,</span> <span class="kt">string</span> <span class="n">firstName</span><span class="p">,</span> <span class="kt">string</span> <span class="n">lastName</span><span class="p">,</span> <span class="n">ContactLevel</span> <span class="n">level</span><span class="p">)</span>
</code></pre></div>
<p>Now asking AutoFixture to resolve <code>Contact</code> will cause it to resolve <code>PersonId</code>&#39; and <code>ContactLevel</code>.  But aren&#39;t we back where we started?  Again, <code>PersonId</code> must take a numeric string and <code>ContactLevel</code> must take an integer between 1 and 3.  Should we extend <code>ContactGenerator</code> to include that logic?  In my opinion, definitely not.  <code>ContactGenerator</code> doesn&#39;t have any special rules around the <code>PersonId</code> and <code>ContactLevel</code> it can take, it just requires that it receive instances of each so imbuing it with the rules for creating a Contact don&#39;t really make sense.  </p>
 
	</p>
  
</div>


 
	
	<nav id="pagination">
    
    
     
    <a href="/page2/" title="Next Page">Next &raquo;</a>
     
  </nav>

</body>
</html>