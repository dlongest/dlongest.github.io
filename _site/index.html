<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Code Like A Champion</title>
		
		 <link href="/css/bootstrap.css" rel="stylesheet">
		 <link rel="icon" href="/images/logo.png" />
		 <script type="text/javascript" src="/js/jquery.js"></script>
		<script type="text/javascript" src="/js/bootstrap.js"></script>		
    <!-- Custom CSS -->
		<link href="/css/logo-nav.css" rel="stylesheet" />	
		<link href="/css/custom.css" rel="stylesheet" />
		<link rel="stylesheet" href="/css/solarized-dark.css" type="text/css"/> 

		<link href='http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic,700italic' rel='stylesheet' type='text/css' />
    </head>
    <body>
	 <nav class="navbar navbar-inverse navbar-fixed-top" role="navigation">
        <div class="container">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="/">
                    <img id="logo" src='/images/logo.png' width="125" height="125" />
                </a>
            </div>
            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav">
                    <li>
                        <a href="/about.html">About</a>
                    </li>
					  <li>
                        <a href="#">Categories</a>
                    </li>                                       
                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>	

<div class="container">
<div class="row">
 <div class="col-lg-12">		
          
	<h2><a href="/2015/03/10/cte-and-windowing-functions.html">Basics of Common Table Expressions and Windowing Functions</a></h2>
	<div class="date">10 March 2015</div>	
	<div class="post">
	<p>Most developers are aware of how to use basic SQL constructs (Select, Update, Insert) even if their level of database programming is very minimal.  I was fortunate that before I was a fulltime developer, I worked in a role that required me to read, write, and troubleshoot an intense amount of SQL (and actually wasn&#39;t a DBA job).  Over the course of time, I became pretty fair at SQL and others used to bring me random SQL problems for help.  Most of these were straightforward enough problems, but occasionally I would get one that was really difficult, and I really enjoyed those.  Last night a current colleague of mine emailed me about a problem he was having doing some integration work and the solution was a set of SQL Server features that I think deserve to be talked about more:  common table expressions (CTE) and windowing functions.  There&#39;s a lot of power there and it can be overwhelming so the point of this post is to simply describe the problem and then illustrate how CTE and windowing functions made the solution pretty trivial.  </p>

<p>Here&#39;s the problem:  we have a table of data about employment applicants (i.e. people who have applied for jobs) in a legacy system.  We&#39;re moving to a new system so we need to take the data from the first system and transform it into a format required by the second system so it can be imported.  </p>

<p>First, here&#39;s the data in the legacy system in a single table (greatly stripped down for illustrative purposes, the real one has about 250+ columns):</p>

<table class="sql">
<tr><th>Name</th><th>Phone</th><th>EyeColor</th><th>PositionID</th><th>Title</th></tr>
<tr><td>Franklin</td><td>1212</td><td>Blue</td><td>123</td><td>General Manager</td></tr>
<tr><td>Franklin</td><td>1212</td><td>Blue</td><td>67</td><td>Salesman</td></tr>
<tr><td>Pierce</td><td>1313</td><td>Blue</td><td>234</td><td>Digger</td></tr>
<tr><td>Pierce</td><td>1313</td><td>Blue</td><td>456</td><td>Porter</td></tr>
<tr><td>Hoolihan</td><td>1414</td><td>Green</td><td>123</td><td>General Manager</td></tr>
<tr><td>Bob</td><td>1515</td><td>Blue</td><td>86</td><td>Maid</td></tr>
<tr><td>Bob</td><td>1515</td><td>Blue</td><td>90</td><td>Electrician</td></tr>
</table>

<p>We&#39;ll call Name, Phone, and EyeColor the &quot;key&quot; fields.  That&#39;s a bit of a misnomer since these keys don&#39;t uniquely identify a single record, but I&#39;m using the term simply to mean that those values are the same for a single person.  We need to sequentially number each record with the same key (and we&#39;ll call it PositionCount).  Franklin has two records so the first is 1 and the second is 2, but Hoolihan has only a single record so its sole record is 1.  We only want to print the key fields for the first position record; otherwise we want to print blanks for the key fields, but still print the position data.  Here&#39;s how we want the data to look for loading into the target system.  </p>

<table class="sql">
<tr><th>Name</th><th>Phone</th><th>EyeColor</th><th>PositionID</th><th>Title</th><th>PositionCount</th></tr>
<tr><td>Franklin</td><td>1212</td><td>Blue</td><td>123</td><td>General Manager</td><td>1</td></tr>
<tr><td></td><td></td><td></td><td>67</td><td>Salesman</td><td>2</td></tr>
<tr><td>Pierce</td><td>1313</td><td>Blue</td><td>234</td><td>Digger</td><td>1</td></tr>
<tr><td></td><td></td><td></td><td>456</td><td>Porter</td><td>2</td></tr>
<tr><td>Hoolihan</td><td>1414</td><td>Green</td><td>123</td><td>General Manager</td><td>1</td></tr>
<tr><td>Bob</td><td>1515</td><td>Blue</td><td>86</td><td>Maid</td><td>1</td></tr>
<tr><td></td><td></td><td></td><td>90</td><td>Electrician</td><td>2</td></tr>
</table>

<p>The first part to tackle:  how can we determine the position counts?  Most people can instantly think of an imperative solution (just loop through the records, adding an incrementing value to that column, resetting for each person), but in SQL we want to think relationally.  A <code>Group By</code> would let us group the records by our keys, but at best we could obtain a count of the records in the group, not quite what we want.  It&#39;s here that a windowing function really shines.  </p>

<p>At the most basic level, a windowing function lets us define a partition (which is similar to a group) against which we can execute some statement.  Below is the SQL that will do the job for me:</p>
<div class="highlight"><pre><code class="sql language-sql" data-lang="sql"><span class="k">select</span> <span class="o">*</span><span class="p">,</span> <span class="n">row_number</span><span class="p">()</span> <span class="n">over</span> <span class="p">(</span><span class="n">partition</span> <span class="k">by</span> <span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="k">order</span> <span class="k">by</span> <span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="k">asc</span><span class="p">)</span> <span class="k">as</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span> <span class="k">from</span> <span class="n">Persons</span><span class="p">)</span>
</code></pre></div>
<p>Probably not terribly hard to understand, but the <code>OVER</code> function is the windowing function.  We instruct it to partition our set based on <code>Name</code>, then order it by <code>Name</code> (which is required), then apply SQL Server&#39;s row_number() function within each partition.  This will have the effect we want: the first record in each partition will get the value 1, the next 2, and so on, but the counts reset for each partition.  By modifying the partition columns, you can control to what level the records are numbered.  See the documentation on the  <a href="https://msdn.microsoft.com/en-us/library/ms189461.aspx">OVER function on MSDN</a> to learn more.   The shown SQL is now capable of providing this result set:</p>

<table class="sql">
<tr><th>Name</th><th>Phone</th><th>EyeColor</th><th>PositionID</th><th>Title</th><th>PositionCount</th></tr>
<tr><td>Franklin</td><td>1212</td><td>Blue</td><td>123</td><td>General Manager</td><td>1</td></tr>
<tr><td>Franklin</td><td>1212</td><td>Blue</td><td>67</td><td>Salesman</td><td>2</td></tr>
<tr><td>Pierce</td><td>1313</td><td>Blue</td><td>234</td><td>Digger</td><td>1</td></tr>
<tr><td>Pierce</td><td>1313</td><td>Blue</td><td>456</td><td>Porter</td><td>2</td></tr>
<tr><td>Hoolihan</td><td>1414</td><td>Green</td><td>123</td><td>General Manager</td><td>1</td></tr>
<tr><td>Bob</td><td>1515</td><td>Blue</td><td>86</td><td>Maid</td><td>1</td></tr>
<tr><td>Bob</td><td>1515</td><td>Blue</td><td>90</td><td>Electrician</td><td>2</td></tr>
</table>

<p>From here, what we want to achieve is conceptually pretty easy:  we only want to print the value of the key fields when <code>PositionCount</code> is 1, otherwise we want to print a blank (or null).  We could of course make a new table (either temporary or real) and put our newly formed result set in that, then operate against it, but a common table expression (a CTE) is for me faster to develop (albeit with some caveats I&#39;ll cover at the end). </p>

<p>What is a common table expression (CTE)?  Without cribbing directly from Microsoft on the subject, it&#39;s in many ways an in-memory view.  You provide it with a name and you can thereafter use that name for the result set, same as you would a query.  The CTE can be used recursively in other queries and combined in some very powerful ways.  They are incredibly useful if you&#39;ll be referencing the same table or result set multiple times within a query as you can apply a name to that set and just use the name.  And due to how they&#39;re defined, they make queries a lot easier to read as they basically build from the top down in an organized fashion, which is genearlly far easier to decipher than a query with a lot of nested queries. </p>

<p>A CTE is defined in either of the forms:</p>
<div class="highlight"><pre><code class="sql language-sql" data-lang="sql"><span class="k">WITH</span> <span class="p">(</span><span class="n">CTE</span> <span class="n">Name</span><span class="o">&gt;</span> <span class="k">AS</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">query</span> <span class="n">definition</span><span class="o">&gt;</span><span class="p">)</span> 

<span class="k">WITH</span> <span class="o">&lt;</span><span class="n">CTE</span> <span class="n">Name</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">&lt;</span><span class="k">column</span> <span class="k">names</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">AS</span> <span class="p">(</span><span class="o">&lt;</span><span class="n">query</span> <span class="n">definition</span><span class="o">&gt;</span><span class="p">)</span>
</code></pre></div>
<p>The first form defines a CTE with the given name and its columns will be all the columns from the query definition.  The second allows you to specify the column names you want available in the CTE; these are drawn from the query definition.  Only those columns defined in the CTE are then avaiable.  So what&#39;s the point of the CTE?  You can then use it like a table: </p>
<div class="highlight"><pre><code class="sql language-sql" data-lang="sql"><span class="k">with</span> <span class="n">PositionsCounted</span> <span class="k">as</span> <span class="p">(</span><span class="k">select</span> <span class="o">*</span><span class="p">,</span> <span class="n">row_number</span><span class="p">()</span> <span class="n">over</span> <span class="p">(</span><span class="n">partition</span> <span class="k">by</span> <span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="k">order</span> <span class="k">by</span> <span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="k">asc</span><span class="p">)</span> <span class="k">as</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span> <span class="k">from</span> <span class="n">Persons</span><span class="p">)</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">PositionsCounted</span>
</code></pre></div>
<p>The above SQL is equivalent to just executing the query definition directly, all we&#39;ve really done at this point is given the result set a name we can operate against.  But for the final piece, we can do this to produce our final result set:</p>
<div class="highlight"><pre><code class="sql language-sql" data-lang="sql"><span class="k">with</span> <span class="n">PositionsCounted</span> <span class="k">as</span> <span class="p">(</span><span class="k">select</span> <span class="o">*</span><span class="p">,</span> <span class="n">row_number</span><span class="p">()</span> <span class="n">over</span> <span class="p">(</span><span class="n">partition</span> <span class="k">by</span> <span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="k">order</span> <span class="k">by</span> <span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="k">asc</span><span class="p">)</span> <span class="k">as</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span> <span class="k">from</span> <span class="n">Persons</span><span class="p">)</span>
<span class="k">select</span> <span class="k">case</span> <span class="k">when</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">then</span> <span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="k">end</span><span class="p">,</span>
       <span class="k">case</span> <span class="k">when</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">then</span> <span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="p">[</span><span class="n">Phone</span><span class="p">]</span> <span class="k">end</span><span class="p">,</span>
       <span class="k">case</span> <span class="k">when</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">then</span> <span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="p">[</span><span class="n">EyeColor</span><span class="p">]</span> <span class="k">end</span><span class="p">,</span>
       <span class="p">[</span><span class="n">PositionID</span><span class="p">],</span> <span class="p">[</span><span class="n">Title</span><span class="p">],</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span> 
       <span class="k">from</span> <span class="n">PositionsCounted</span>
</code></pre></div>
<p>The trick to this SQL is that for each of our key fields, we inspect the value of <code>PositionCount</code> and that determines what we should output (either the value of the column or a blank).  Otherwise, we simply want the non-key fields returned as-is.  Obviously this approach is difficult to scale if there are hundreds of key fields (as each would have to be added manually as a case expression), but in this case when there&#39;s only a minimal number of key fields, it&#39;s trivial. </p>

<p>CTEs can be combined as well, such as the below, which simply puts the output of the first CTE into the second, a trivial but hopefully illustrative example:</p>
<div class="highlight"><pre><code class="sql language-sql" data-lang="sql"><span class="k">with</span> <span class="n">PositionsCounted</span> <span class="k">as</span> <span class="p">(</span><span class="k">select</span> <span class="o">*</span><span class="p">,</span> <span class="n">row_number</span><span class="p">()</span> <span class="n">over</span> <span class="p">(</span><span class="n">partition</span> <span class="k">by</span> <span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="k">order</span> <span class="k">by</span> <span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="k">asc</span><span class="p">)</span> <span class="k">as</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span> <span class="k">from</span> <span class="n">Persons</span><span class="p">),</span>
<span class="n">OutputReady</span> <span class="k">as</span> 
<span class="p">(</span><span class="k">select</span> <span class="k">case</span> <span class="k">when</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">then</span> <span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="p">[</span><span class="n">Name</span><span class="p">]</span> <span class="k">end</span> <span class="p">[</span><span class="n">Name</span><span class="p">],</span>
       <span class="k">case</span> <span class="k">when</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">then</span> <span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="p">[</span><span class="n">Phone</span><span class="p">]</span> <span class="k">end</span> <span class="p">[</span><span class="n">Phone</span><span class="p">],</span>
       <span class="k">case</span> <span class="k">when</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span> <span class="k">then</span> <span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="p">[</span><span class="n">EyeColor</span><span class="p">]</span> <span class="k">end</span> <span class="p">[</span><span class="n">EyeColor</span><span class="p">],</span>
       <span class="p">[</span><span class="n">PositionID</span><span class="p">],</span> <span class="p">[</span><span class="n">Title</span><span class="p">],</span> <span class="p">[</span><span class="n">PositionCount</span><span class="p">]</span> 
       <span class="k">from</span> <span class="n">PositionsCounted</span><span class="p">)</span>
<span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">OutputReady</span>
</code></pre></div>
<p>So we&#39;ve seen some benefits of CTE, what are the downsides?  First, they are only in scope for a single query.  If you want to reuse them, they have to be copied and pasted into all places that need to reference them.  If you have such a need, temp tables or something more permanent (or semi-permanent) is a better bet.  Second, because they do not exist in tempdb, you cannot add indexes or anything that would improve the performance (and constraints and stats are likewise not available).  Again, if that&#39;s your need, a temp table would be more in order.  </p>

<p>I hope you&#39;ve enjoyed this basic look at common table expressions and windowing functions in SQL Server.  This has only scratched the surface of these features so I definitely suggest working through some examples to get a feel for how and when each can be applied in real life situations.  </p>
 	
	</div>
	<hr />
      
	<h2><a href="/2015/03/07/intro-to-specimen-builders-in-autofixture.html">Introduction to Custom Specimen Builders in AutoFixture</a></h2>
	<div class="date">7 March 2015</div>	
	<div class="post">
	<p>It is no secret at work that I greatly admire Mark Seemann.  Anyone that comes to me and asks about software design I steer them right to his book &quot;Dependency Injection in .NET&quot;.  In some respects, the title does it a bit of a disservice as at least half of it discusses some critical component design practices that apply regardless of whether one wants to use dependency injection.  Don&#39;t get me wrong, he covers dependency injection quite comprehensively, but there&#39;s a lot more to DI than just picking a container.  Beyond his book, Mark is an incredibly accessible guy in a couple respects.  One, he blogs pretty regularly and has a lot of incredible posts on design, I find myself going back to them again and again.  And two, he is the author of AutoFixture, which needs almost no introduction in the .NET world.  And it is this library that is the subject of this post. </p>

<p>When I explain AutoFixture to other developers, I start by emphasizing its most straightforward use: when writing unit tests, it will provide you with test data with almost no setup, as if by magic.  Whether you needs integers or strings or collections or even complex objects, AutoFixture will provide them to you in a semi-random fashion.  Within the AutoFixture codebase, the components that handle creation of some value are termed specimen builders and they inherit <code>ISpecimenBuilder</code>.  A few common examples:  </p>

<ul>
<li><code>Int32Generator</code> is the specimen builder that generates integers, beginning at 1 and incrementing by 1 for each subsequent integer that the fixture creates.<br></li>
<li><code>StringGenerator</code> generates strings and the default randomization is to append a GUID to the name of the property or field</li>
<li><code>RandomRangedNumberGenerator</code> generates a random number within a given range, but doesn&#39;t repeat numbers in that range until all values have been used (shameless plug: I submitted this to AutoFixture)</li>
</ul>

<p>And of course there are plenty more beyond that that do a variety of things.  Mark has an older but still valid post from 2010 on how to approach creating a custom specimen builder, but I think there&#39;s some nuances to it that aren&#39;t entirely clear to new users of AutoFixture.  I know when I introduced AutoFixture at work we used it in a sub-optimal manner because it wasn&#39;t always clear how to best customize it for certain situations and I want to save others some effort in the future since there isn&#39;t always time to dig into new libraries like one would hope.  This in no way takes away from how incredible AutoFixture is or how responsive Mark and others (Adam Chester and Nikos Baxevanis among them) are to questions about it on Stack Overflow or elsewhere, just my attempt to contribute some first-hand experience and perspective.</p>

<p>The <code>ISpecimenBuilder</code> interface has the following signature (taken directly from the AutoFixture codebase):</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">    <span class="k">public</span> <span class="k">interface</span> <span class="n">ISpecimenBuilder</span>
    <span class="p">{</span>        
        <span class="kt">object</span> <span class="nf">Create</span><span class="p">(</span><span class="kt">object</span> <span class="n">request</span><span class="p">,</span> <span class="n">ISpecimenContext</span> <span class="n">context</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>
<p>Here, <code>request</code> is <em>something</em> that needs to be created (and I&#39;ll come back to that in a minute).  The <code>context</code> can be used if necessary to generate other values from the fixture, but is not always needed.  For example, <code>Int32Generator</code> has no need of the <code>context</code> as it contains all the knowledge for satisfying its creation goals.  But suppose you&#39;re creating a specimen builder for a complex type and in the course of that, you want AutoFixture to provide some value (of any type)?  In that case you can use the <code>context</code> to obtain it (I&#39;m intentionally omitting why you get <code>ISpecimenContext</code> and not <code>IFixture</code>).  </p>

<p>Request is ambiguously typed as <code>object</code> - what is it?  Typically, <code>request</code> is one of:</p>

<ul>
<li>A <code>Type</code></li>
<li>A <code>PropertyInfo</code></li>
<li>A <code>ParameterInfo</code></li>
</ul>

<p>And that brings us finally to the point of this post:  why on earth is that and what does it mean for us trying to create a custom specimen builder?</p>

<p>We&#39;ll start with the most obvious, Type.  At the most basic level, use of AutoFixture generally looks like:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">    <span class="kt">var</span> <span class="n">fixture</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Fixture</span><span class="p">();</span>            
    <span class="kt">var</span> <span class="n">contact</span> <span class="p">=</span> <span class="n">fixture</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="n">Contact</span><span class="p">&gt;();</span>
</code></pre></div>
<p>We create a Fixture, then we ask it for the type <code>Contact</code>, which is defined as:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">     <span class="k">public</span> <span class="k">class</span> <span class="nc">Contact</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">Contact</span><span class="p">(</span><span class="kt">string</span> <span class="n">personId</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">PersonId</span> <span class="p">=</span> <span class="n">personId</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">string</span> <span class="n">PersonId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span>  <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<p>AutoFixture now attempts to satisfy the request for a contact by running it through a variety of specimen builders in an implementation of the powerful chain of responsibility pattern.  The chain in this case is (among other things) a collection of specimen builders that individually assess whether they are capable of providing a value of type <code>Contact</code>.  The request to create it falls through each builder in the chain until one finally returns an actual <code>Contact</code> (each returns a <code>NoSpecimen</code> if it cannot handle the request).  But what does it mean to create a Contact?  </p>

<p>As shown, AutoFixture will find that Contact has one constructor and that this constructor takes a string.  So AutoFixture will automatically attempt to resolve creation of a string, then use that to create the <code>Contact</code> via its constructor.  This would be true regardless of how many dependencies the constructor had or their type.  And if there are multiple constructors, AutoFixture selects among them (by default, taking the one with the fewest parameters).  So from that view, AutoFixture creating an instance of an arbitrary complex type is simply the creation of any dependencies of that type until the entire graph is constructed. </p>

<p>Now let&#39;s say for the sake of argument that PersonId, despite being typed as a string, is actually numeric.  We&#39;ve already seen earlier that AutoFixture, by default, will make strings whose value are the property name and a GUID so we know that the default is not going to work for us here.  The first and easiest approach to this is:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">    <span class="kt">var</span> <span class="n">fixture</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Fixture</span><span class="p">();</span>
    <span class="n">fixture</span><span class="p">.</span><span class="n">Register</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="s">&quot;12345678&quot;</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">contact</span> <span class="p">=</span> <span class="n">fixture</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="n">Contact</span><span class="p">&gt;();</span>
</code></pre></div>
<p>This solves one problem (PersonId on the Contact will be &quot;12345678&quot;) <em>except</em> this will cause AutoFixture to use &quot;12345678&quot; for every string it creates.  So we&#39;ve overreached a bit here.  Of course we could use some method that generates a random integer and uses that instead of a hard-coded one, but again, it will use that random numeric string everywhere.  At some point, it might occur to us &quot;What if we could customize the creation of Contact as a whole instead of at the string level?&quot;  Enter a custom specimen builder.  </p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">    <span class="k">public</span> <span class="k">class</span> <span class="nc">ContactGenerator</span> <span class="p">:</span> <span class="n">ISpecimenBuilder</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">object</span> <span class="nf">Create</span><span class="p">(</span><span class="kt">object</span> <span class="n">request</span><span class="p">,</span> <span class="n">ISpecimenContext</span> <span class="n">context</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">type</span> <span class="p">=</span> <span class="n">request</span> <span class="k">as</span> <span class="n">Type</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
                <span class="k">return</span> <span class="k">new</span> <span class="nf">NoSpecimen</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="p">!=</span> <span class="k">typeof</span><span class="p">(</span><span class="n">Contact</span><span class="p">))</span>
                <span class="k">return</span> <span class="k">new</span> <span class="nf">NoSpecimen</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>

            <span class="k">return</span> <span class="k">new</span> <span class="nf">Contact</span><span class="p">(</span><span class="s">&quot;12345678&quot;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<p>So here, what is <code>request</code>?  Well remember, we&#39;re asking the Fixture to resolve <code>Contact</code> for us and our specimen builder&#39;s purpose is to create an entire <code>Contact</code> so <code>request</code> would be a Type.  But it&#39;s not just any arbitrary <code>Type</code>, our builder would only care about <code>Contact</code>.  The builder above follows a standard form:  attempt to cast <code>request</code> into what it&#39;s able to operate on, ensure that we did indeed get a request we can handle (returning <code>NoSpecimen</code> if we can&#39;t), and then create our desired instance.  In the above, we&#39;re hardcoding &quot;12345678&quot; as the parameter to the <code>Contact</code> constructor.  What if we want AutoFixture to make a random integer for us to use for that purpose?  Simple enough to use the <code>context</code> to resolve that for us:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">    <span class="k">return</span> <span class="k">new</span> <span class="nf">Contact</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;().</span><span class="n">ToString</span><span class="p">());</span>
</code></pre></div>
<p>Now we&#39;re able to create a <code>Contact</code> with a properly numeric PersonId whose value is being provided by the fixture&#39;s normal integer rules.  The final step is to tell AutoFixture about the specimen builder:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">    <span class="n">fixture</span><span class="p">.</span><span class="n">Customizations</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">new</span> <span class="n">ContactGenerator</span><span class="p">());</span>
</code></pre></div>
<p>Now you have a specimen builder capable of constructing a given type for you and perhaps that is sufficient for your needs.  But let&#39;s say <code>Contact</code> gets a bit more interesting:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">    <span class="k">public</span> <span class="k">class</span> <span class="nc">Contact</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">Contact</span><span class="p">(</span><span class="kt">string</span> <span class="n">personId</span><span class="p">,</span> <span class="kt">string</span> <span class="n">firstName</span><span class="p">,</span> <span class="kt">string</span> <span class="n">lastName</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">/// elided</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">string</span> <span class="n">PersonId</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">public</span> <span class="kt">int</span> <span class="n">Level</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="n">FirstName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="n">LastName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<p>So here our contact has a PersonId (using the same numeric string rules as before), a level (an integer from 1 to 3), and first name and last name.  Let&#39;s assume that names are not particularly interesting, but there are valid reasons to use different levels in your testing, but again, they must be constrained within a specified range.  </p>

<p>We can let AutoFixture just provide us with random strings for the names, but we cannot simply ask it for an integer for level as we must constrain it to a certain range.  How can we support that?  Of course one way is to extend our <code>ContactGenerator</code> class to now include rules for constraining levels.  That might look like:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">     <span class="k">return</span> <span class="k">new</span> <span class="nf">Contact</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;().</span><span class="n">ToString</span><span class="p">(),</span>
                               <span class="n">context</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(),</span> <span class="n">context</span><span class="p">.</span><span class="n">Create</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;(),</span>
                               <span class="k">new</span> <span class="nf">Random</span><span class="p">().</span><span class="n">Next</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">3</span><span class="p">));</span>
</code></pre></div>
<p>This seems to work fine, but something about it feels a little off.  For one, we&#39;ve got a lot of rules about our system and its valid inputs buried within this builder instead of having them be explicit.  Sometimes, this suggests the need to make a concept more explicit, possibly by introducing <code>PersonId</code> and <code>Level</code> as value objects that properly communicate our intent.  Let&#39;s say we introduce such types as shown below:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">    <span class="k">public</span> <span class="k">class</span> <span class="nc">PersonId</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">PersonId</span><span class="p">(</span><span class="kt">string</span> <span class="n">personId</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(!</span><span class="n">personId</span><span class="p">.</span><span class="n">IsNumeric</span><span class="p">())</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="s">&quot;personId&quot;</span><span class="p">);</span>

            <span class="k">this</span><span class="p">.</span><span class="n">Id</span> <span class="p">=</span> <span class="n">personId</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">string</span> <span class="n">Id</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">class</span> <span class="nc">ContactLevel</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">ContactLevel</span><span class="p">(</span><span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="p">&lt;=</span> <span class="m">0</span> <span class="p">||</span> <span class="n">level</span> <span class="p">&gt;</span> <span class="m">3</span><span class="p">)</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="s">&quot;level&quot;</span><span class="p">);</span>

            <span class="k">this</span><span class="p">.</span><span class="n">Level</span> <span class="p">=</span> <span class="n">level</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">int</span> <span class="n">Level</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div>
<p>That changes our <code>Contact</code> constructor to:</p>
<div class="highlight"><pre><code class="csharp language-csharp" data-lang="csharp">    <span class="k">public</span> <span class="nf">Contact</span><span class="p">(</span><span class="n">PersonId</span> <span class="n">personId</span><span class="p">,</span> <span class="kt">string</span> <span class="n">firstName</span><span class="p">,</span> <span class="kt">string</span> <span class="n">lastName</span><span class="p">,</span> <span class="n">ContactLevel</span> <span class="n">level</span><span class="p">)</span>
</code></pre></div>
<p>Now asking AutoFixture to resolve <code>Contact</code> will cause it to resolve <code>PersonId</code>&#39; and <code>ContactLevel</code>.  But aren&#39;t we back where we started?  Again, <code>PersonId</code> must take a numeric string and <code>ContactLevel</code> must take an integer between 1 and 3.  Should we extend <code>ContactGenerator</code> to include that logic?  In my opinion, definitely not.  <code>ContactGenerator</code> doesn&#39;t have any special rules around the <code>PersonId</code> and <code>ContactLevel</code> it can take, it just requires that it receive instances of each so imbuing it with the rules for creating a Contact don&#39;t really make sense.   Of course we can create additional specimen builders for <code>ContactLevel</code> and <code>PersonId</code> and put the rules for each in those and that will work fine, but there is another main type of specimen builder that we need to discuss and that will be the subject of a future post. </p>
 	
	</div>
	<hr />
  



 
	</div>
</div>
</div>
<ul class="pager">
 	
	  
	 <li>
    <a  href="/page2/" title="Older">Older &raquo;</a>
	</li>
     
</ul>		
   


  
	
</body>
</html>